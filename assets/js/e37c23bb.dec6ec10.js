"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[142],{790:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var o=n(1966),a=(n(9496),n(9613)),r=n(7934),s=n(4575);const l={description:"Learn how to structure your Reflex project."},d="Organizing Producers",i={unversionedId:"guides/organizing-producers",id:"guides/organizing-producers",title:"Organizing Producers",description:"Learn how to structure your Reflex project.",source:"@site/docs/guides/organizing-producers.md",sourceDirName:"guides",slug:"/guides/organizing-producers",permalink:"/reflex/docs/guides/organizing-producers",draft:!1,tags:[],version:"current",frontMatter:{description:"Learn how to structure your Reflex project."},sidebar:"learnSidebar",previous:{title:"Your First Producer",permalink:"/reflex/docs/guides/your-first-producer"},next:{title:"Using Selectors",permalink:"/reflex/docs/guides/using-selectors"}},c={},u=[{value:"The root producer",id:"the-root-producer",level:2},{value:"Defining slices",id:"defining-slices",level:2},{value:"Defining a root producer",id:"defining-a-root-producer",level:2},{value:"Using the root producer",id:"using-the-root-producer",level:3},{value:"Summary",id:"summary",level:2}],p={toc:u},m="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"organizing-producers"},"Organizing Producers"),(0,a.kt)("p",null,"Everything you need to read and update your state can be contained within a single producer. However, as your game scales, you might prefer to split up your code into multiple files."),(0,a.kt)("admonition",{title:"we discuss:",type:"note"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"\ud83c\udf82 What a root producer is"),(0,a.kt)("li",{parentName:"ul"},"\ud83c\udf70 How to split producers into multiple slices"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\udce6 How to export your slices and its types"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\udcc2 Creating a root producer"))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"the-root-producer"},"The root producer"),(0,a.kt)("p",null,"The root producer is the entry point for your game's state and actions. You'll use it to perform all of your state updates and subscribe to your state."),(0,a.kt)("p",null,"In the ",(0,a.kt)("a",{parentName:"p",href:"your-first-producer#creating-a-producer"},"Your First Producer")," guide, we created a producer called ",(0,a.kt)("inlineCode",{parentName:"p"},"todos"),":"),(0,a.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.ts"',title:'"todos.ts"'},'import { createProducer } from "@rbxts/reflex";\n\n// ...\n\nexport const todos = createProducer(initialState, {\n    addTodo: (state, todo: string) => ({\n        ...state,\n        todos: [...state.todos, todo],\n    }),\n\n    removeTodo: (state, todo: string) => ({\n        ...state,\n        todos: state.todos.filter((t) => t !== todo),\n    }),\n});\n'))),(0,a.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="todos.lua"',title:'"todos.lua"'},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\n-- ...\n\nlocal todos = Reflex.createProducer(initialState, {\n    addTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.insert(nextTodos, todo)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n\n    removeTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.remove(nextTodos, table.find(nextTodos, todo) or -1)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n}) :: TodosProducer\n")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"As our game grows, our state grows in complexity.")," For example, we might want to add a calendar to track upcoming events. Instead of repurposing our ",(0,a.kt)("inlineCode",{parentName:"p"},"todos")," producer to include the calendar, it would be better to create ",(0,a.kt)("em",{parentName:"p"},"slices"),"."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"defining-slices"},"Defining slices"),(0,a.kt)("p",null,"A ",(0,a.kt)("em",{parentName:"p"},"producer slice")," is a subset of your root producer's state and actions. Instead of being used on their own, they are used to ",(0,a.kt)("a",{parentName:"p",href:"#defining-a-root-producer"},"define your root producer"),". By splitting up your producers into slices, you can keep your code organized and easy to maintain."),(0,a.kt)("p",null,"Here, both ",(0,a.kt)("inlineCode",{parentName:"p"},"todos")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar")," have been made into producer slices:"),(0,a.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="File structure"',title:'"File','structure"':!0},"producer\n\u251c\u2500\u2500 calendar.ts\n\u251c\u2500\u2500 todos.ts\n\u2514\u2500\u2500 index.ts\n")),(0,a.kt)(r.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"Todos",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.ts" showLineNumbers',title:'"todos.ts"',showLineNumbers:!0},'import { createProducer } from "@rbxts/reflex";\n\nexport interface TodosState {\n    readonly todos: readonly string[];\n}\n\nconst initialState: TodosState = {\n    todos: [],\n};\n\nexport const todosSlice = createProducer(initialState, {\n    addTodo: (state, todo: string) => ({\n        ...state,\n        todos: [...state.todos, todo],\n    }),\n\n    removeTodo: (state, todo: string) => ({\n        ...state,\n        todos: state.todos.filter((t) => t !== todo),\n    }),\n});\n'))),(0,a.kt)(s.Z,{value:"Calendar",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="calendar.ts" showLineNumbers',title:'"calendar.ts"',showLineNumbers:!0},'import { createProducer } from "@rbxts/reflex";\n\nexport interface CalendarState {\n    readonly events: readonly CalendarEvent[];\n}\n\nexport interface CalendarEvent {\n    readonly name: string;\n    readonly date: number;\n}\n\nconst initialState: CalendarState = {\n    events: [],\n};\n\nexport const calendarSlice = createProducer(initialState, {\n    addEvent: (state, event: CalendarEvent) => ({\n        ...state,\n        events: [...state.events, event],\n    }),\n\n    removeEvent: (state, name: string) => ({\n        ...state,\n        events: state.events.filter((e) => e.name !== name),\n    }),\n});\n'))))),(0,a.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="File structure"',title:'"File','structure"':!0},"producer\n\u251c\u2500\u2500 calendar.lua\n\u251c\u2500\u2500 todos.lua\n\u2514\u2500\u2500 init.lua\n")),(0,a.kt)(r.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"Todos",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="todos.lua" showLineNumbers',title:'"todos.lua"',showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nexport type TodosState = {\n    todos: { string }\n}\n\nexport type TodosActions = {\n    addTodo: (todo: string) -> (),\n    removeTodo: (todo: string) -> (),\n}\n\nlocal initialState: TodosState = {\n    todos = {},\n}\n\nlocal todosSlice = Reflex.createProducer(initialState, {\n    addTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.insert(nextTodos, todo)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n\n    removeTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.remove(nextTodos, table.find(nextTodos, todo) or -1)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n})\n\nreturn { todosSlice = todosSlice }\n"))),(0,a.kt)(s.Z,{value:"Calendar",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="calendar.lua" showLineNumbers',title:'"calendar.lua"',showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nexport type CalendarState = {\n    events: { CalendarEvent }\n}\n\nexport type CalendarEvent = {\n    name: string,\n    date: string,\n}\n\nexport type CalendarActions = {\n    addEvent: (event: CalendarEvent) -> (),\n    removeEvent: (event: CalendarEvent) -> (),\n}\n\nlocal initialState: CalendarState = {\n    events = {},\n}\n\nlocal calendarSlice = Reflex.createProducer(initialState, {\n    addEvent = function(state: CalendarState, event: CalendarEvent): CalendarState\n        local nextState = table.clone(state)\n        local nextEvents = table.clone(state.events)\n\n        table.insert(nextEvents, event)\n        nextState.events = nextEvents\n\n        return nextState\n    end,\n\n    removeEvent = function(state: CalendarState, name: string): CalendarState\n        local nextState = table.clone(state)\n        local nextEvents: { CalendarEvent } = {}\n\n        for _, event in state.events do\n            if event.name ~= name then\n                table.insert(nextEvents, event)\n            end\n        end\n\n        nextState.events = nextEvents\n\n        return nextState\n    end,\n})\n\nreturn { calendarSlice = calendarSlice }\n")))),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"We export ",(0,a.kt)("inlineCode",{parentName:"p"},"TodosState")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"TodosActions")," to make it easier to type our root producer, since type inference in Luau is not as powerful as TypeScript.")))),(0,a.kt)("p",null,"Our state has been broken into two slices:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"todosSlice")," manages a list of todos."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"calendarSlice")," tracks events on a calendar.")),(0,a.kt)("p",null,"These slices can then be ",(0,a.kt)("strong",{parentName:"p"},"combined")," into a root producer."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"defining-a-root-producer"},"Defining a root producer"),(0,a.kt)("p",null,"The root producer file is where you'll combine all of your slices into a single producer. This file is the entry point for managing your game's state, and also exports some utility types to help us later. You can combine your slices with ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/combine-producers"},(0,a.kt)("inlineCode",{parentName:"a"},"combineProducers")),":"),(0,a.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="index.ts" showLineNumbers',title:'"index.ts"',showLineNumbers:!0},'import { CombineStates, combineProducers } from "@rbxts/reflex";\nimport { todosSlice } from "./todos";\nimport { calendarSlice } from "./calendar";\n\nexport type RootProducer = typeof producer;\n\nexport type RootState = CombineStates<RootProducer>;\n\nexport const producer = combineProducers({\n    todos: todosSlice,\n    calendar: calendarSlice,\n});\n'))),(0,a.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="init.lua" showLineNumbers',title:'"init.lua"',showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\nlocal todos = require(script.todos)\nlocal calendar = require(script.calendar)\n\nexport type RootProducer = Reflex.Producer<RootState, RootActions>\n\nexport type RootState = {\n    todos: todos.TodosState,\n    calendar: calendar.CalendarState,\n}\n\ntype RootActions = todos.TodosActions & calendar.CalendarActions\n\nreturn Reflex.combineProducers({\n    todos = todos.todosSlice,\n    calendar = calendar.calendarSlice,\n}) :: RootProducer\n")))),(0,a.kt)("p",null,"Now that we have a root producer, we can use the state and actions from our slices. Calling ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/combine-producers"},(0,a.kt)("inlineCode",{parentName:"a"},"combineProducers"))," does three things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Combine")," the state from each slice using the shape you provided."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Expose")," the actions from each slice under the root producer."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Merge")," any actions that have the same name.")),(0,a.kt)("p",null,"With this, we can now access all of our state and actions from the root producer."),(0,a.kt)("h3",{id:"using-the-root-producer"},"Using the root producer"),(0,a.kt)("p",null,"As mentioned above, combining slices into a root producer exposes the actions from each slice under the root producer. This means that we can call the todo list's ",(0,a.kt)("inlineCode",{parentName:"p"},"addTodo")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"removeTodo")," from the root producer, and it will update the state of ",(0,a.kt)("inlineCode",{parentName:"p"},"todos"),":"),(0,a.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="example.ts" showLineNumbers',title:'"example.ts"',showLineNumbers:!0},'import { RootState, producer } from "./producer";\n\nconst selectTodos = (state: RootState) => state.todos.todos;\n\nproducer.subscribe(selectTodos, (todos) => {\n    print(`TODO: ${todos.join(", ")}`);\n});\n\nproducer.addTodo("Buy milk");\nproducer.addTodo("Buy eggs");\n'))),(0,a.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="example.lua" showLineNumbers',title:'"example.lua"',showLineNumbers:!0},'local producer = require(script.Parent.producer)\n\nlocal function selectTodos(state: producer.RootState)\n    return state.todos.todos\nend\n\nproducer:subscribe(selectTodos, function(todos)\n    print("TODO: " .. table.concat(todos, ", "))\nend)\n\nproducer.addTodo("Buy milk")\nproducer.addTodo("Buy eggs")\n')))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# TODO: Buy milk, Buy eggs\n")),(0,a.kt)("p",null,"Or, we can call the calendar's ",(0,a.kt)("inlineCode",{parentName:"p"},"addEvent")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"removeEvent")," from the root producer, and it will update the state of ",(0,a.kt)("inlineCode",{parentName:"p"},"calendar"),":"),(0,a.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="example.ts" showLineNumbers',title:'"example.ts"',showLineNumbers:!0},'import { RootState, producer } from "./producer";\n\nconst selectEvents = (state: RootState) => state.calendar.events;\n\nproducer.subscribe(selectEvents, (events) => {\n    print("EVENTS:");\n    for (const event of events) {\n        print(`- ${event.name} (${event.date})`);\n    }\n});\n\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\nproducer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\n'))),(0,a.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="example.lua" showLineNumbers',title:'"example.lua"',showLineNumbers:!0},'local producer = require(script.Parent.producer)\n\nlocal function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\nproducer:subscribe(selectEvents, function(events)\n    print("EVENTS:")\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\nproducer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\n')))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# EVENTS:\n# - Birthday (2004-12-27)\n# - Learn Reflex (2023-03-17)\n")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("strong",{parentName:"p"},"You should only call actions from the root producer.")," Calling actions from a slice will not update the state of the root producer, and vice versa.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The root producer is the ",(0,a.kt)("strong",{parentName:"li"},"entry point")," for your game's state."),(0,a.kt)("li",{parentName:"ul"},"Your actions and state are exposed under the root producer."),(0,a.kt)("li",{parentName:"ul"},"You can use ",(0,a.kt)("strong",{parentName:"li"},"slices")," to break up your state into smaller pieces."),(0,a.kt)("li",{parentName:"ul"},"You can ",(0,a.kt)("strong",{parentName:"li"},"combine slices")," into a root producer with ",(0,a.kt)("a",{parentName:"li",href:"../reference/reflex/combine-producers"},(0,a.kt)("inlineCode",{parentName:"a"},"combineProducers")),".")))}g.isMDXComponent=!0}}]);