"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[350],{5386:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var a=n(8028),r=(n(9496),n(9613)),o=n(4638),u=n(9372),l=n(2013);const i={sidebar_position:1,description:"Manage your game's state with producers."},s="createProducer",c={unversionedId:"reference/reflex/create-producer",id:"reference/reflex/create-producer",title:"createProducer",description:"Manage your game's state with producers.",source:"@site/docs/reference/reflex/create-producer.md",sourceDirName:"reference/reflex",slug:"/reference/reflex/create-producer",permalink:"/reflex/docs/reference/reflex/create-producer",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Manage your game's state with producers."},sidebar:"referenceSidebar",previous:{title:"Reflex",permalink:"/reflex/docs/reference/reflex/"},next:{title:"Producer",permalink:"/reflex/docs/reference/reflex/producer"}},d={},p=[{value:"Reference",id:"reference",level:2},{value:"<code>createProducer(initialState, actions)</code>",id:"createproducerinitialstate-actions",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Usage",id:"usage",level:2},{value:"Updating state with actions",id:"updating-state-with-actions",level:3},{value:"Updating nested state",id:"updating-nested-state",level:3},{value:"Importing and exporting types",id:"importing-and-exporting-types",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Actions aren&#39;t triggering a state update",id:"actions-arent-triggering-a-state-update",level:3}],m={toc:p},g="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(g,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"createproducer"},"createProducer"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createProducer")," lets you create a ",(0,r.kt)("a",{parentName:"p",href:"producer"},"producer")," that contains a part of your game's state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(initialState, actions);\n")),(0,r.kt)(l.Z,{toc:p,mdxType:"TOCInline"}),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("h3",{id:"createproducerinitialstate-actions"},(0,r.kt)("inlineCode",{parentName:"h3"},"createProducer(initialState, actions)")),(0,r.kt)("p",null,"Creates a ",(0,r.kt)("a",{parentName:"p",href:"producer"},"producer")," initialized with the given ",(0,r.kt)("inlineCode",{parentName:"p"},"initialState")," and merged with your ",(0,r.kt)("inlineCode",{parentName:"p"},"actions"),"."),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(0, {\n    increment: (state, value: number) => state + value,\n    decrement: (state, value: number) => state - value,\n    set: (_, value: number) => value,\n});\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type Actions = {\n    increment: (value: number) -> (),\n}\n\nlocal producer = Reflex.createProducer(0, {\n    increment = function(state, value: number): number\n        return state + value\n    end,\n    decrement = function(state, value: number): number\n        return state - value\n    end,\n    set = function(_, value: number): number\n        return value\n    end,\n}) :: Reflex.Producer<number, Actions>\n")))),(0,r.kt)("p",null,"Actions define how the state should be updated. They are pure functions that receive the current state and some parameters, and return a new state. They can be dispatched through the producer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.increment(1); // state = 1\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#usage"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"initialState")," - The initial state of the producer."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"actions")," - An object containing action functions.")),(0,r.kt)("h4",{id:"returns"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createProducer")," returns a Reflex ",(0,r.kt)("a",{parentName:"p",href:"producer"},"producer")," that you can use to dispatch actions and subscribe to state changes."),(0,r.kt)("admonition",{title:"caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"State must be immutable.")," Instead of mutating any part of the state, actions should return a new state object. Otherwise, the producer won't be able to detect state changes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Actions should be pure and idempotent.")," Ideally, they would not have any side effects, and should always return the same state for the same parameters.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"updating-state-with-actions"},"Updating state with actions"),(0,r.kt)("p",null,"Producers are the state containers that you can use to dispatch actions and observe state changes. They work with ",(0,r.kt)("em",{parentName:"p"},"immutable data"),", ensuring safety and predictability when working with state."),(0,r.kt)("p",null,"Typically, games and apps keep all of their state in a single root producer. This allows them to easily observe and modify any part of the state."),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"createProducer")," to create a producer with an initial state and action functions:"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"See libraries like ",(0,r.kt)("a",{parentName:"p",href:"https://csqrl.github.io/sift/"},"Sift")," and ",(0,r.kt)("a",{parentName:"p",href:"https://solarhorizon.github.io/immut/"},"Immut")," for utilities that make it easier to work with immutable data.")),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface CounterState {\n    readonly count: number;\n}\n\nconst initialState: CounterState = {\n    count: 0,\n};\n\nconst producer = createProducer(initialState, {\n    increment: (state, value: number) => ({\n        ...state,\n        count: state.count + value,\n    }),\n    // ...\n});\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type CounterState = {\n    count: number,\n}\n\ntype CounterActions = {\n    increment: (value: number) -> (),\n    -- ...\n}\n\nlocal initialState: CounterState = {\n    count = 0,\n}\n\nlocal producer = Reflex.createProducer(initialState, {\n    increment = function(state, value: number): CounterState\n        return { count = state.count + value }\n    end,\n    -- ...\n}) :: Reflex.Producer<CounterState, CounterActions>\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createProducer")," returns a producer combined with your action functions. Producers can update their state by dispatching actions:"),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.increment(1);\nproducer.getState(); // { count: 1 }\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer.increment(1)\nproducer:getState() --\x3e { count = 1 }\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"updating-nested-state"},"Updating nested state"),(0,r.kt)("p",null,"Because state is immutable, updating nested state can be a bit tricky, especially in Luau."),(0,r.kt)("p",null,"The easiest way to do this is to use a library like ",(0,r.kt)("a",{parentName:"p",href:"https://csqrl.github.io/sift/"},"Sift")," or ",(0,r.kt)("a",{parentName:"p",href:"https://solarhorizon.github.io/immut/"},"Immut")," to update nested state, but you can also do it manually:"),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface TodoState {\n    readonly todos: readonly Todo[];\n}\n\ninterface Todo {\n    readonly text: string;\n    readonly completed: boolean;\n}\n\nconst initialState: CounterState = {\n    entries: {},\n};\n\nconst producer = createProducer(initialState, {\n    addTodo: (state, text: string) => ({\n        ...state,\n        todos: [...state.todos, { text, completed: false }],\n    }),\n\n    toggleTodo: (state, index: number) => ({\n        ...state,\n        todos: state.todos.map((todo, i) => {\n            if (i !== index) {\n                return todo;\n            }\n            return { ...todo, completed: !todo.completed };\n        }),\n    }),\n});\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type TodoState = {\n    todos: { Todo },\n}\n\ntype TodoActions = {\n    addTodo: (text: string) -> (),\n    toggleTodo: (index: number) -> (),\n}\n\ntype Todo = {\n    text: string,\n    completed: boolean,\n}\n\nlocal initialState: TodoState = {\n    todos = {},\n}\n\nlocal producer = Reflex.createProducer(initialState, {\n    addTodo = function(state, test: string): TodoState\n        // highlight-start\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n        // highlight-end\n\n        table.insert(nextTodos, { text = text, completed = false })\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n\n    toggleTodo = function(state, index: number): TodoState\n        // highlight-start\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n        local nextTodo = table.clone(state.todos[index])\n        // highlight-end\n\n        nextTodo.completed = not nextTodo.completed\n        nextTodos[index] = nextTodo\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n}) :: Reflex.Producer<TodoState, TodoActions>\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"importing-and-exporting-types"},"Importing and exporting types"),(0,r.kt)("p",null,"Usually, a project will organize its state between multiple producers in separate files, and then combine them into a single producer."),(0,r.kt)("p",null,"Producer modules should export the type of their state (and actions in Luau). This allows you to use a fully typed root producer that contains all of your actions and state."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This is not required in TypeScript, since types can be inferred from the producer object.")),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="counter.ts"',title:'"counter.ts"'},"export interface CounterState {\n    readonly count: number;\n}\n\nconst initialState: CounterState = {\n    count: 0,\n};\n\nexport const counterSlice = createProducer(initialState, {\n    increment: (state, value: number) => ({\n        ...state,\n        count: state.count + value,\n    }),\n    // ...\n});\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="root-producer.ts"',title:'"root-producer.ts"'},'import { InferState } from "@rbxts/reflex";\nimport { counterSlice } from "./counter";\n\nexport type RootProducer = typeof producer;\n\nexport type RootState = InferState<RootProducer>;\n\nexport const producer = combineProducers({\n    counter: counterSlice,\n    // ...\n});\n'))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="counter.lua"',title:'"counter.lua"'},"export type CounterState = {\n    count: number,\n}\n\nexport type CounterActions = {\n    increment: (value: number) -> (),\n    -- ...\n}\n\nlocal initialState: CounterState = {\n    count = 0,\n}\n\nlocal counterSlice = Reflex.createProducer(initialState, {\n    increment = function(state, value: number): CounterState\n        return { count = state.count + value }\n    end,\n    -- ...\n})\n\nreturn {\n    counterSlice = counterSlice,\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="init.lua"',title:'"init.lua"'},"local counter = require(script.Parent.counter)\nlocal other = require(script.Parent.other)\n\nexport type RootProducer = Reflex.Producer<RootState, RootActions>\n\nexport type RootState = {\n    counter: counter.CounterState,\n    other: other.OtherState,\n}\n\nexport type RootActions = counter.CounterActions &\n    other.OtherActions\n\nreturn Reflex.combineProducers({\n    counter = counter.counterSLice,\n    other = other.otherSlice,\n}) :: RootProducer\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"combine-producers"},"Learn more about combining producers")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,r.kt)("h3",{id:"actions-arent-triggering-a-state-update"},"Actions aren't triggering a state update"),(0,r.kt)("p",null,"If you're dispatching actions, but your state listeners don't run when they should, make sure that your action functions ",(0,r.kt)("strong",{parentName:"p"},"do not")," mutate the state."),(0,r.kt)("p",null,"Code like this assumes a ",(0,r.kt)("em",{parentName:"p"},"mutable")," state object:"),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(initialState, {\n    increment: (state, value: number) => {\n        // error-next-line\n        // \ud83d\udd34 You are not allowed to mutate state\n        // error-next-line\n        state.count += value;\n        return state;\n    },\n});\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local producer = Reflex.createProducer(initialState, {\n    increment = function(state, value: number): CounterState\n        // error-next-line\n        -- \ud83d\udd34 You are not allowed to mutate state\n        // error-next-line\n        state.count += value\n        return state\n    end,\n})\n")))),(0,r.kt)("p",null,"This action does not return a new state object. As far as Reflex knows, the new state is equal (",(0,r.kt)("inlineCode",{parentName:"p"},"==="),") to the old state, so it assumes that nothing has changed."),(0,r.kt)("p",null,"To fix this, apply the changes to a new object and return it:"),(0,r.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(u.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(initialState, {\n    // highlight-start\n    // \u2705 Apply changes to a new object instead of mutating\n    increment: (state, value: number) => ({\n        ...state,\n        count: state.count + value,\n    }),\n    // highlight-end\n});\n"))),(0,r.kt)(u.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local producer = Reflex.createProducer(initialState, {\n    increment = function(state, value: number): CounterState\n        // highlight-start\n        -- \u2705 Apply changes to a new object instead of mutating\n        local nextState = table.clone(state)\n        nextState.count += value\n        return nextState\n        // highlight-end\n    end,\n})\n")))),(0,r.kt)("p",null,"This action returns a new state object, so that Reflex knows the state has changed and will trigger state listeners."),(0,r.kt)("p",null,"This problem can also occur with nested state objects, so make sure to apply changes to a new object at every level of your state."))}h.isMDXComponent=!0}}]);