"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[282],{9613:(e,r,t)=>{t.d(r,{Zo:()=>i,kt:()=>b});var a=t(9496);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function c(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var u=a.createContext({}),s=function(e){var r=a.useContext(u),t=r;return e&&(t="function"==typeof e?e(r):l(l({},r),e)),t},i=function(e){var r=s(e.components);return a.createElement(u.Provider,{value:r},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},m=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,o=e.originalType,u=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),p=s(t),m=n,b=p["".concat(u,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(b,l(l({ref:r},i),{},{components:t})):a.createElement(b,l({ref:r},i))}));function b(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var o=t.length,l=new Array(o);l[0]=m;var c={};for(var u in r)hasOwnProperty.call(r,u)&&(c[u]=r[u]);c.originalType=e,c[p]="string"==typeof e?e:n,l[1]=c;for(var s=2;s<o;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4575:(e,r,t)=>{t.d(r,{Z:()=>l});var a=t(9496),n=t(5924);const o={tabItem:"tabItem_rlDe"};function l(e){let{children:r,hidden:t,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,n.Z)(o.tabItem,l),hidden:t},r)}},7934:(e,r,t)=>{t.d(r,{Z:()=>P});var a=t(1966),n=t(9496),o=t(5924),l=t(6888),c=t(3442),u=t(4475),s=t(8423),i=t(1010);function p(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:r,label:t,attributes:a,default:n}}=e;return{value:r,label:t,attributes:a,default:n}}))}function d(e){const{values:r,children:t}=e;return(0,n.useMemo)((()=>{const e=r??p(t);return function(e){const r=(0,s.l)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,t])}function m(e){let{value:r,tabValues:t}=e;return t.some((e=>e.value===r))}function b(e){let{queryString:r=!1,groupId:t}=e;const a=(0,c.k6)(),o=function(e){let{queryString:r=!1,groupId:t}=e;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:r,groupId:t});return[(0,u._X)(o),(0,n.useCallback)((e=>{if(!o)return;const r=new URLSearchParams(a.location.search);r.set(o,e),a.replace({...a.location,search:r.toString()})}),[o,a])]}function f(e){const{defaultValue:r,queryString:t=!1,groupId:a}=e,o=d(e),[l,c]=(0,n.useState)((()=>function(e){let{defaultValue:r,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!m({value:r,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${r}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return r}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:r,tabValues:o}))),[u,s]=b({queryString:t,groupId:a}),[p,f]=function(e){let{groupId:r}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(r),[a,o]=(0,i.Nk)(t);return[a,(0,n.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),g=(()=>{const e=u??p;return m({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{g&&c(g)}),[g]);return{selectedValue:l,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),s(e),f(e)}),[s,f,o]),tabValues:o}}var g=t(6648);const h={tabList:"tabList_t2F_",tabItem:"tabItem_TXTv"};function k(e){let{className:r,block:t,selectedValue:c,selectValue:u,tabValues:s}=e;const i=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),d=e=>{const r=e.currentTarget,t=i.indexOf(r),a=s[t].value;a!==c&&(p(r),u(a))},m=e=>{let r=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=i.indexOf(e.currentTarget)+1;r=i[t]??i[0];break}case"ArrowLeft":{const t=i.indexOf(e.currentTarget)-1;r=i[t]??i[i.length-1];break}}r?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},r)},s.map((e=>{let{value:r,label:t,attributes:l}=e;return n.createElement("li",(0,a.Z)({role:"tab",tabIndex:c===r?0:-1,"aria-selected":c===r,key:r,ref:e=>i.push(e),onKeyDown:m,onClick:d},l,{className:(0,o.Z)("tabs__item",h.tabItem,l?.className,{"tabs__item--active":c===r})}),t??r)})))}function y(e){let{lazy:r,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(r){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,r)=>(0,n.cloneElement)(e,{key:r,hidden:e.props.value!==a}))))}function v(e){const r=f(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",h.tabList)},n.createElement(k,(0,a.Z)({},e,r)),n.createElement(y,(0,a.Z)({},e,r)))}function P(e){const r=(0,g.Z)();return n.createElement(v,(0,a.Z)({key:String(r)},e))}},6332:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>u,default:()=>b,frontMatter:()=>c,metadata:()=>s,toc:()=>p});var a=t(1966),n=(t(9496),t(9613)),o=t(7934),l=t(4575);const c={sidebar_position:3},u="combineProducers",s={unversionedId:"reference/reflex/apis/combine-producers",id:"reference/reflex/apis/combine-producers",title:"combineProducers",description:"combineProducers lets you combine multiple producers into a single producer.",source:"@site/docs/reference/reflex/apis/combine-producers.md",sourceDirName:"reference/reflex/apis",slug:"/reference/reflex/apis/combine-producers",permalink:"/reflex/docs/reference/reflex/apis/combine-producers",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"referenceSidebar",previous:{title:"Producer",permalink:"/reflex/docs/reference/reflex/apis/producer"},next:{title:"createSelector",permalink:"/reflex/docs/reference/reflex/apis/create-selector"}},i={},p=[{value:"Reference",id:"reference",level:2},{value:"<code>combineProducers(producers)</code>",id:"combineproducersproducers",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Usage",id:"usage",level:2},{value:"Using multiple producers",id:"using-multiple-producers",level:3},{value:"Selecting combined state",id:"selecting-combined-state",level:3},{value:"Dispatching one action to multiple producers",id:"dispatching-one-action-to-multiple-producers",level:3}],d={toc:p},m="wrapper";function b(e){let{components:r,...t}=e;return(0,n.kt)(m,(0,a.Z)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"combineproducers"},"combineProducers"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"combineProducers")," lets you combine multiple ",(0,n.kt)("a",{parentName:"p",href:"producer"},"producers")," into a single producer."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = combineProducers({\n    foo: fooProducer,\n    bar: barProducer,\n    // ...\n});\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#reference"},"Reference"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#combineproducersproducers"},(0,n.kt)("inlineCode",{parentName:"a"},"combineProducers(producers)"))))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#usage"},"Usage"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#using-multiple-producers"},"Using multiple producers")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#selecting-combined-state"},"Selecting combined state")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#dispatching-one-action-to-multiple-producers"},"Dispatching one action to multiple producers"))))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"reference"},"Reference"),(0,n.kt)("h3",{id:"combineproducersproducers"},(0,n.kt)("inlineCode",{parentName:"h3"},"combineProducers(producers)")),(0,n.kt)("p",null,"To combine multiple ",(0,n.kt)("a",{parentName:"p",href:"producer"},"producers"),", pass them into ",(0,n.kt)("inlineCode",{parentName:"p"},"combineProducers")," as a map of names to producers."),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const fooProducer = createProducer(0, {\n    incrementFoo: (state, value: number) => state + value,\n});\n\nconst barProducer = createProducer(0, {\n    incrementBar: (state, value: number) => state + value,\n});\n\nconst producer = combineProducers({\n    foo: fooProducer,\n    bar: barProducer,\n});\n"))),(0,n.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"local fooProducer = createProducer(0, {\n    incrementFoo = function(state, value: number)\n        return state + value\n    end,\n})\n\nlocal barProducer = createProducer(0, {\n    incrementBar = function(state, value: number)\n        return state + value\n    end,\n})\n\nlocal producer = Redux.combineProducers({\n    foo = fooProducer,\n    bar = barProducer,\n})\n")))),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"combineProducers")," will return a new ",(0,n.kt)("a",{parentName:"p",href:"producer"},"producer")," with state organized using the keys passed in ",(0,n.kt)("inlineCode",{parentName:"p"},"producers"),". Actions are merged together and will update the state of the corresponding sub-state."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"producer.incrementFoo(1); // { foo: 1, bar: 0 }\nproducer.incrementBar(1); // { foo: 1, bar: 1 }\n")),(0,n.kt)("p",null,"A game managed by Reflex will typically have a single root producer that contains all of the game's state. State can be organized into sub-producers to make it easier to manage and update."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"#usage"},"See more examples below.")),(0,n.kt)("h4",{id:"parameters"},"Parameters"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"producers")," - An object containing the ",(0,n.kt)("a",{parentName:"li",href:"producer"},"producers")," to combine. The combined producer's state will organize the state by the keys of this object. Actions are merged together and will update the state of the corresponding sub-state.")),(0,n.kt)("h4",{id:"returns"},"Returns"),(0,n.kt)("p",null,"A new ",(0,n.kt)("a",{parentName:"p",href:"producer"},"producer")," with the combined initial states and actions of the given producers."),(0,n.kt)("admonition",{title:"Caveats",type:"info"},(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The producer returned by ",(0,n.kt)("inlineCode",{parentName:"p"},"combineProducers")," is decoupled from the original producers. Updating the state of the combined producer will not update the state of the original producers.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Unlike state, combined actions are ",(0,n.kt)("em",{parentName:"p"},"not")," scoped to their respective producers. If two actions with the same name are dispatched, they will both be called and update their respective sub-states.")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"usage"},"Usage"),(0,n.kt)("h3",{id:"using-multiple-producers"},"Using multiple producers"),(0,n.kt)("p",null,"It's good practice to organize state into different producers, and combine them with ",(0,n.kt)("a",{parentName:"p",href:"combine-producers"},(0,n.kt)("inlineCode",{parentName:"a"},"combineProducers")),". This makes it easier to manage state and update it in a predictable way."),(0,n.kt)("p",null,"Let's say we have a game that has a page router and a leaderboard. We can create a file for each sub-producer, and combine them into a single root producer:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"producer\n\u251c\u2500\u2500 router\n\u2514\u2500\u2500 leaderboard\n")),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"In TypeScript, you should use ",(0,n.kt)("inlineCode",{parentName:"p"},"InferState")," or an equivalent type to export the root state from the root producer file. This is for easy access to state for certain features like ",(0,n.kt)("a",{parentName:"p",href:"producer#running-side-effects"},"selectors")," and Hooks.")),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"router.ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},'import { createProducer } from "@rbxts/reflex";\n\nexport interface RouterState {\n    readonly page: string;\n}\n\nconst initialState: RouterState = {\n    page: "home",\n};\n\nexport const routerProducer = createProducer(initialState, {\n    setPage: (state, page: string) => ({ ...state, page }),\n});\n'))),(0,n.kt)(l.Z,{value:"leaderboard.ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},'import { createProducer } from "@rbxts/reflex";\n\nexport interface LeaderboardState {\n    readonly players: readonly number[];\n}\n\nconst initialState: LeaderboardState = {\n    players: [],\n};\n\nexport const leaderboardProducer = createProducer(initialState, {\n    addPlayer: (state, player: number) => ({\n        ...state,\n        players: [...state.players, player],\n    }),\n\n    removePlayer: (state, player: number) => ({\n        ...state,\n        players: state.players.filter((p) => p !== player),\n    }),\n});\n'))),(0,n.kt)(l.Z,{value:"index.ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},'import { combineProducers, InferState } from "@rbxts/reflex";\nimport { routerProducer } from "./router";\nimport { leaderboardProducer } from "./leaderboard";\n\nexport type RootProducer = typeof producer;\n\nexport type RootState = InferState<RootProducer>;\n\nexport const producer = combineProducers({\n    router: routerProducer,\n    leaderboard: leaderboardProducer,\n});\n'))),(0,n.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},'import { producer } from "./producer";\n\nproducer.setPage("leaderboard");\n// --\x3e { router: { page: "leaderboard" }, ... }\n\nproducer.addPlayer(123);\n// --\x3e { leaderboard: { players: [123] }, ... }\n'))))),(0,n.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"In Luau, you should exporting the types from each producer file and manually combine them in the root producer file. This allows you to have a type-safe root producer with intellisense for state and actions.")),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"router.lua",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local Reflex = require(ReplicatedStorage.Packages.reflex)\n\nexport type RouterState = {\n    page: string,\n}\n\nexport type RouterDispatchers = {\n    setPage: (page: string) -> RouterState,\n}\n\nlocal initialState: RouterState = {\n    page = "home",\n}\n\nlocal routerProducer = Reflex.createProducer(initialState, {\n    setPage = function(state, page: string)\n        return { page = page }\n    end,\n})\n\nreturn {\n    producer = routerProducer,\n}\n'))),(0,n.kt)(l.Z,{value:"leaderboard.lua",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.reflex)\n\nexport type LeaderboardState = {\n    players: { number },\n}\n\nexport type LeaderboardDispatchers = {\n    addPlayer: (player: number) -> LeaderboardState,\n    removePlayer: (player: number) -> LeaderboardState,\n}\n\nlocal initialState: LeaderboardState = {\n    players = {},\n}\n\nlocal leaderboardProducer = Reflex.createProducer(initialState, {\n    addPlayer = function(state, player: number)\n        local nextState = table.clone(state)\n        local nextPlayers = table.clone(state.players)\n\n        table.insert(nextPlayers, player)\n        nextState.players = nextPlayers\n\n        return nextState\n    end,\n\n    removePlayer = function(state, player: number)\n        local nextState = table.clone(state)\n        local nextPlayers = table.clone(state.players)\n\n        table.remove(nextPlayers, table.find(nextPlayers, player) or -1)\n        nextState.players = nextPlayers\n\n        return nextState\n    end,\n})\n\nreturn {\n    producer = leaderboardProducer,\n}\n"))),(0,n.kt)(l.Z,{value:"init.lua",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.reflex)\nlocal router = require(script.router)\nlocal leaderboard = require(script.leaderboard)\n\nexport type RootProducer = Reflex.Producer<RootState, RootDispatchers>\n\nexport type RootState = {\n    router: router.RouterState,\n    leaderboard: leaderboard.LeaderboardState,\n}\n\nexport type RootDispatchers = router.RouterDispatchers &\n    leaderboard.LeaderboardDispatchers\n\nreturn Reflex.combineProducers({\n    router = router.producer,\n    leaderboard = leaderboard.producer,\n}) :: RootProducer\n"))),(0,n.kt)(l.Z,{value:"Usage",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'local Reflex = require(ReplicatedStorage.Packages.reflex)\nlocal producer = require(script.Parent.producer)\n\nproducer.setPage("leaderboard")\n--\x3e { router = { page = "leaderboard" }, ... }\n\nproducer.addPlayer(123)\n--\x3e { leaderboard = { players = { 123 } }, ... }\n')))))),(0,n.kt)("p",null,"Remember that the combined producer is decoupled from the original producers. Updating the state of the combined producer will not update the state of the original producers, and vice versa."),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"selecting-combined-state"},"Selecting combined state"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"combine-producers"},(0,n.kt)("inlineCode",{parentName:"a"},"combineProducers"))," will organize state by the keys of the given ",(0,n.kt)("inlineCode",{parentName:"p"},"producers")," object. This makes it easy to select state from the combined producer."),(0,n.kt)("p",null,"Assuming we have the ",(0,n.kt)("a",{parentName:"p",href:"#using-multiple-producers"},"same producers from above"),", we create selectors for the leaderboard like so:"),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="selectors/leaderboard.ts"',title:'"selectors/leaderboard.ts"'},'import { Players } from "@rbxts/services";\nimport { createSelector } from "@rbxts/reflex";\nimport { RootState } from "../producer";\n\nexport const selectLeaderboardUserIds = (state: RootState) => {\n    return state.leaderboard.players;\n};\n\nexport const selectLeaderboardPlayers = createSelector([selectLeaderboardUserIds], (userIds) => {\n    return userIds.mapFiltered((userId) => Players.GetPlayerByUserId(userId));\n});\n'))),(0,n.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="selectors/leaderboard.lua"',title:'"selectors/leaderboard.lua"'},'local Players = game:GetService("Players")\nlocal ReplicatedStorage = game:GetService("ReplicatedStorage")\n\nlocal Reflex = require(ReplicatedStorage.Packages.reflex)\nlocal producer = require(script.Parent.Parent.producer)\n\nlocal function selectLeaderboardUserIds(state: producer.RootState)\n    return state.leaderboard.players\nend\n\nlocal selectLeaderboardPlayers = Reflex.createSelector(\n    { selectLeaderboardUserIds },\n    function(userIds: { number })\n        local players = {}\n        for _, userId in userIds do\n            table.insert(players, Players:GetPlayerByUserId(userId))\n        end\n        return players\n    end\n)\n\nreturn {\n    selectLeaderboardUserIds = selectLeaderboardUserIds,\n    selectLeaderboardPlayers = selectLeaderboardPlayers,\n}\n')))),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"create-selector"},(0,n.kt)("inlineCode",{parentName:"a"},"createSelector"))," for more information on how to create selectors."),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"dispatching-one-action-to-multiple-producers"},"Dispatching one action to multiple producers"),(0,n.kt)("p",null,"A caveat of ",(0,n.kt)("a",{parentName:"p",href:"combine-producers"},(0,n.kt)("inlineCode",{parentName:"a"},"combineProducers"))," is that combined actions are not scoped to their respective producers. Any name collisions will result in a dispatch calling ",(0,n.kt)("em",{parentName:"p"},"all")," actions with the same name."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"But you can use this to your advantage!")," If you want to dispatch actions from multiple producers at once, it's as simple as giving them the same name. We'll go over how to do this and cover some use cases."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Here's a simple example of dispatching one action to multiple producers:")),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const fooProducer = createProducer(0, {\n    // highlight-next-line\n    increment: (state, value: number) => state + value,\n});\n\nconst barProducer = createProducer(0, {\n    // highlight-next-line\n    increment: (state, value: number) => state + value,\n});\n\nconst producer = combineProducers({\n    foo: fooProducer,\n    bar: barProducer,\n});\n\n// highlight-next-line\nproducer.increment(1); // { foo: 1, bar: 1 }\n"))),(0,n.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"local fooProducer = Reflex.createProducer(0, {\n    // highlight-next-line\n    increment = function(state, value: number)\n        return state + value\n    end,\n})\n\nlocal barProducer = Reflex.createProducer(0, {\n    // highlight-next-line\n    increment = function(state, value: number)\n        return state + value\n    end,\n})\n\nlocal producer = Reflex.combineProducers({\n    foo = fooProducer,\n    bar = barProducer,\n})\n\n// highlight-next-line\nproducer.increment(1) --\x3e { foo = 1, bar = 1 }\n")))),(0,n.kt)("p",null,"Here, ",(0,n.kt)("inlineCode",{parentName:"p"},"increment")," executes ",(0,n.kt)("strong",{parentName:"p"},"a single dispatch call"),". However, it updates the state of both ",(0,n.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"bar"),", which originate from different producers. By allowing a name collision, we can dispatch to multiple producers at once."),(0,n.kt)("p",null,"Some use cases for this include:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Resetting state:")," A ",(0,n.kt)("inlineCode",{parentName:"p"},"reset")," action can reset the state of multiple producers at once.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Global events:")," A script can dispatch a ",(0,n.kt)("inlineCode",{parentName:"p"},"playerAdded")," action to multiple producers to notify them of a new player.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Modular player save data:")," A ",(0,n.kt)("inlineCode",{parentName:"p"},"playerDataOpen")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"playerDataClose")," action can be dispatched to multiple producers to initialize and clear player data."))))}b.isMDXComponent=!0}}]);