"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[107],{9613:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var r=a(9496);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=c(a),m=n,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||o;return a?r.createElement(h,s(s({ref:t},d),{},{components:a})):r.createElement(h,s({ref:t},d))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:n,s[1]=i;for(var c=2;c<o;c++)s[c]=a[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3469:(e,t,a)=>{a.d(t,{Z:()=>s});var r=a(9496),n=a(5924);const o={tabItem:"tabItem_rlDe"};function s(e){let{children:t,hidden:a,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,n.Z)(o.tabItem,s),hidden:a},t)}},6187:(e,t,a)=>{a.d(t,{Z:()=>S});var r=a(1966),n=a(9496),o=a(5924),s=a(2180),i=a(3442),l=a(2799),c=a(441),d=a(1006);function u(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:r,default:n}}=e;return{value:t,label:a,attributes:r,default:n}}))}function p(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??u(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const r=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,o=p(e),[s,i]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=a.find((e=>e.default))??a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[l,c]=h({queryString:a,groupId:r}),[u,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,d.Nk)(a);return[r,(0,n.useCallback)((e=>{a&&o.set(e)}),[a,o])]}({groupId:r}),y=(()=>{const e=l??u;return m({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{y&&i(y)}),[y]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),c(e),f(e)}),[c,f,o]),tabValues:o}}var y=a(4230);const b={tabList:"tabList_t2F_",tabItem:"tabItem_TXTv"};function v(e){let{className:t,block:a,selectedValue:i,selectValue:l,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.o5)(),p=e=>{const t=e.currentTarget,a=d.indexOf(t),r=c[a].value;r!==i&&(u(t),l(r))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const a=d.indexOf(e.currentTarget)+1;t=d[a]??d[0];break}case"ArrowLeft":{const a=d.indexOf(e.currentTarget)-1;t=d[a]??d[d.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},c.map((e=>{let{value:t,label:a,attributes:s}=e;return n.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>d.push(e),onKeyDown:m,onClick:p},s,{className:(0,o.Z)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":i===t})}),a??t)})))}function g(e){let{lazy:t,children:a,selectedValue:r}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function k(e){const t=f(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},n.createElement(v,(0,r.Z)({},e,t)),n.createElement(g,(0,r.Z)({},e,t)))}function S(e){const t=(0,y.Z)();return n.createElement(k,(0,r.Z)({key:String(t)},e))}},7409:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var r=a(1966),n=(a(9496),a(9613)),o=a(6187),s=a(3469);const i={description:"Learn how to use broadcasters to sync state between the server and clients."},l="Server-Client Sync",c={unversionedId:"advanced-guides/server-client-sync",id:"advanced-guides/server-client-sync",title:"Server-Client Sync",description:"Learn how to use broadcasters to sync state between the server and clients.",source:"@site/docs/advanced-guides/server-client-sync.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/server-client-sync",permalink:"/reflex/docs/advanced-guides/server-client-sync",draft:!1,tags:[],version:"current",frontMatter:{description:"Learn how to use broadcasters to sync state between the server and clients."},sidebar:"learnSidebar",previous:{title:"Middleware",permalink:"/reflex/docs/advanced-guides/middleware"}},d={},u=[{value:"Sync server state with clients",id:"sync-server-state-with-clients",level:2},{value:"Sharing state",id:"sharing-state",level:3},{value:"Creating a broadcaster",id:"creating-a-broadcaster",level:3},{value:"Creating a receiver",id:"creating-a-receiver",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Filtering state before sending it to a client",id:"filtering-state-before-sending-it-to-a-client",level:3},{value:"Filtering actions before sending them to a player",id:"filtering-actions-before-sending-them-to-a-player",level:3},{value:"Summary",id:"summary",level:2}],p={toc:u},m="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(m,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"server-client-sync"},"Server-Client Sync"),(0,n.kt)("p",null,"Reflex provides a quick way to sync the server's shared state with clients using ",(0,n.kt)("strong",{parentName:"p"},"broadcasters")," and ",(0,n.kt)("strong",{parentName:"p"},"receivers"),"."),(0,n.kt)("admonition",{title:"what you'll learn",type:"note"},(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},"\ud83c\udf0e What shared producer slices are"),(0,n.kt)("li",{parentName:"ul"},"\ud83d\udd17 How to integrate shared slices into your state"),(0,n.kt)("li",{parentName:"ul"},"\ud83d\udef0\ufe0f How to create broadcasters"),(0,n.kt)("li",{parentName:"ul"},"\ud83d\udce1 How to create receivers"))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"sync-server-state-with-clients"},"Sync server state with clients"),(0,n.kt)("p",null,"Reflex is designed to be used in any environment, on the client and the server. However, in game development, many cases come up where you need to send state from the server to clients. This is where the concept of ",(0,n.kt)("strong",{parentName:"p"},"shared slices")," comes in."),(0,n.kt)("h3",{id:"sharing-state"},"Sharing state"),(0,n.kt)("p",null,"Shared slices are producers that are managed by the server and synced with clients. To create shared slices, we'll follow this project structure:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"shared\n\u251c\u2500\u2500 slices\n\u2502   \u251c\u2500\u2500 calendar\n\u2502   \u2514\u2500\u2500 todos\n\u2514\u2500\u2500 remotes\n")),(0,n.kt)("p",null,"Your shared ",(0,n.kt)("inlineCode",{parentName:"p"},"slices")," module should look something like this:"),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="shared/slices/index.ts" showLineNumbers',title:'"shared/slices/index.ts"',showLineNumbers:!0},'import { CombineStates } from "@rbxts/reflex";\nimport { calendarSlice } from "./calendar";\nimport { todosSlice } from "./todos";\n\nexport type SharedState = CombineStates<typeof sharedSlices>;\n\nexport const sharedSlices = {\n    calendar: calendarSlice,\n    todos: todosSlice,\n};\n')),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"Exporting ",(0,n.kt)("inlineCode",{parentName:"p"},"SharedState")," as a type makes it easier to create typed selectors without importing across the client/server boundary."),(0,n.kt)("pre",{parentName:"admonition"},(0,n.kt)("code",{parentName:"pre",className:"language-ts"},'import { SharedState } from "shared/slices";\n\nexport const selectPlayers = (state: SharedState) => state.players;\n')))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="shared/slices/init.lua" showLineNumbers',title:'"shared/slices/init.lua"',showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\nlocal calendar = require(script.calendar)\nlocal todos = require(script.todos)\n\nexport type SharedState = {\n    calendar: calendar.CalendarState,\n    todos: todos.TodosState,\n}\n\nexport type SharedActions = calendar.CalendarActions & todos.TodosActions\n\nreturn {\n    calendar = calendar.calendarSlice,\n    todos = todos.todosSlice,\n}\n")),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"Exporting ",(0,n.kt)("inlineCode",{parentName:"p"},"SharedState")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"SharedActions")," helps to build a fully-typed root producer.")))),(0,n.kt)("p",null,"In this example, we have two shared producer slices: ",(0,n.kt)("inlineCode",{parentName:"p"},"calendar")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"todos"),". They are put together in a map and returned by ",(0,n.kt)("inlineCode",{parentName:"p"},"shared/slices"),". The contents of these files are not important - they're just like any other producer - but if you want to see how to write producers, ",(0,n.kt)("a",{parentName:"p",href:"../guides/your-first-producer"},"check out this guide")),(0,n.kt)("p",null,"Using a map of shared slices makes it easy to add them to your root producer. In your root producer file, you can import the shared slices and spread them into your root producer:"),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Root producer" showLineNumbers',title:'"Root','producer"':!0,showLineNumbers:!0},'import { InferState, combineProducers } from "@rbxts/reflex";\nimport { sharedSlices } from "shared/slices";\nimport { fooSlice } from "./foo";\nimport { barSlice } from "./bar";\n\nexport type RootState = InferState<typeof producers>;\n\nexport const producer = combineProducers({\n    ...sharedSlices,\n    foo: fooSlice,\n    bar: barSlice,\n});\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Root producer" showLineNumbers',title:'"Root','producer"':!0,showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\nlocal sharedSlices = require(ReplicatedStorage.shared.slices)\nlocal foo = require(script.foo)\nlocal bar = require(script.bar)\n\nexport type RootProducer = Reflex.Producer<RootState, RootActions>\n\nexport type RootState = producers.SharedState &\n    foo.FooState &\n    bar.BarState\n\nexport type RootActions = producers.SharedActions &\n    foo.FooActions &\n    bar.BarActions\n\nlocal slices = {\n    foo = foo.fooSlice,\n    bar = bar.barSlice,\n}\n\nfor name, slice in sharedSlices do\n    slices[name] = slice\nend\n\nreturn Reflex.combineProducers(slices) :: RootProducer\n")),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Libraries like ",(0,n.kt)("a",{parentName:"p",href:"https://csqrl.github.io/sift/"},"Sift")," can make it easier to merge tables in Luau.")))),(0,n.kt)("p",null,"Now that you have your shared state set up, and include them in both your client and server's root producer, you can now use ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcaster#createbroadcasteroptions"},(0,n.kt)("inlineCode",{parentName:"a"},"createBroadcaster"))," to send state to clients."),(0,n.kt)("h3",{id:"creating-a-broadcaster"},"Creating a broadcaster"),(0,n.kt)("p",null,"You should call ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcaster#createbroadcasteroptions"},(0,n.kt)("inlineCode",{parentName:"a"},"createBroadcaster"))," on the server when your game initializes, either before or after you create your root producer. It receives your shared producer map and a function that sends actions to the clients, and returns a broadcaster object. Make sure you've set up remotes as well:"),(0,n.kt)("admonition",{title:"prerequisites",type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"You need remotes to use ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcaster"},(0,n.kt)("inlineCode",{parentName:"a"},"createBroadcaster")),". We recommend ",(0,n.kt)("a",{parentName:"p",href:"http://rbxnet.australis.dev"},"RbxNet"),", which is used in the examples on this page. You need to specify two remotes:"),(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},"A server event that sends actions to a clients. The type of this event would be ",(0,n.kt)("inlineCode",{parentName:"li"},"(actions: BroadcastAction[]) => void"),"."),(0,n.kt)("li",{parentName:"ul"},"A server function that returns the state of the root producer. The type of this function would be ",(0,n.kt)("inlineCode",{parentName:"li"},"(player: Player) => SharedState"),"."))),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Server" showLineNumbers',title:'"Server"',showLineNumbers:!0},'import { createBroadcaster } from "@rbxts/reflex";\nimport { remotes } from "shared/remotes";\nimport { sharedSlices } from "shared/slices";\nimport { producer } from "./producer";\n\nconst broadcast = remotes.Server.Get("broadcast");\nconst requestState = remotes.Server.Get("requestState");\n\nconst broadcaster = createBroadcaster({\n    producers: sharedSlices,\n    broadcast: (players, actions) => {\n        broadcast.SendToPlayers(players, actions);\n    },\n});\n\nrequestState.SetCallback((player) => {\n    return broadcaster.playerRequestedState(player);\n});\n\nproducer.applyMiddleware(broadcaster.middleware);\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Server" showLineNumbers',title:'"Server"',showLineNumbers:!0},'local Reflex = require(ReplicatedStorage.Packages.Reflex)\nlocal remotes = require(ReplicatedStorage.shared.remotes)\nlocal slices = require(ReplicatedStorage.shared.slices)\nlocal producer = require(script.Parent.producer)\n\nlocal broadcast = remotes.Server:Get("broadcast")\nlocal requestState = remotes.Server:Get("requestState")\n\nlocal broadcaster = Reflex.createBroadcaster({\n    producers = slices,\n    broadcast = function(players, actions)\n        broadcast:SendToPlayers(players, actions)\n    end,\n})\n\nrequestState:SetCallback(function(player)\n    return broadcaster:playerRequestedState(player)\nend)\n\nproducer:applyMiddleware(broadcaster.middleware)\n')))),(0,n.kt)("p",null,"This sets up a broadcaster that sends shared actions to the clients when they're dispatched. It also connects a ",(0,n.kt)("inlineCode",{parentName:"p"},"requestState")," remote that returns the state with ",(0,n.kt)("inlineCode",{parentName:"p"},"playerRequestedState"),", which automatically filters out any state that the client doesn't have access to."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcaster"},(0,n.kt)("inlineCode",{parentName:"a"},"createBroadcaster"))," receives two options:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"producers"),": Your ",(0,n.kt)("em",{parentName:"p"},"shared slices"),". This is used to determine which state and actions should be sent to the client.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"broadcast"),": A user-defined callback that sends shared dispatched actions to the clients. It receives an array of actions and an array of players to send them to."))),(0,n.kt)("p",null,"It returns a broadcaster object, which has two properties:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"middleware"),": A Reflex middleware that helps do some of the heavy lifting for you. You should apply this middleware to your root producer. If you have any middlewares that change dispatched arguments, you should apply them after this middleware to ensure that the arguments are preserved.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"playerRequestedState"),": A method that receives the player that requested state, and returns the shared part of the root producer's state."))),(0,n.kt)("admonition",{title:"pitfall",type:"caution"},(0,n.kt)("p",{parentName:"admonition"},(0,n.kt)("strong",{parentName:"p"},"Make sure your shared state can be sent over a remote!")," Objects that use non-string keys or certain values will not be sent over intact. See the ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcaster#troubleshooting"},"troubleshooting")," page for more information on this common pitfall.")),(0,n.kt)("h3",{id:"creating-a-receiver"},"Creating a receiver"),(0,n.kt)("p",null,"Once you have your broadcaster set up, you can use ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/create-broadcast-receiver#createbroadcastreceiveroptions"},(0,n.kt)("inlineCode",{parentName:"a"},"createBroadcastReceiver"))," to initialize the client state with the server's shared state and keep it in sync."),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Client" showLineNumbers',title:'"Client"',showLineNumbers:!0},'import { createBroadcastReceiver } from "@rbxts/reflex";\n\nconst broadcast = remotes.Client.Get("broadcast");\nconst requestState = remotes.Client.Get("requestState");\n\nconst receiver = createBroadcastReceiver({\n    requestInterval: 5,\n    requestState: async () => {\n        return requestState.CallServerAsync();\n    },\n});\n\nbroadcast.Connect((actions) => {\n    receiver.dispatch(actions);\n});\n\nproducer.applyMiddleware(receiver.middleware);\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Client" showLineNumbers',title:'"Client"',showLineNumbers:!0},'local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal broadcast = remotes.Server:Get("broadcast")\nlocal requestState = remotes.Server:Get("requestState")\n\nlocal receiver = Reflex.createBroadcastReceiver({\n    requestInterval = 5,\n    requestState = function()\n        return requestState:CallServerAsync()\n    end,\n})\n\nbroadcast:Connect(function(actions)\n    receiver:dispatch(actions)\nend)\n\nproducer:applyMiddleware(receiver.middleware)\n')))),(0,n.kt)("p",null,"This code will call ",(0,n.kt)("inlineCode",{parentName:"p"},"requestState")," when the middleware is applied, and merge the server's shared state with the client's state. Every ",(0,n.kt)("inlineCode",{parentName:"p"},"requestInterval")," seconds, the client will request the current state of the server, so that the state continues to be kept in sync."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"It's thread-safe,")," so it's safe to apply the middleware at any time, and you can even use your producer before the server's state is received."),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"recipes"},"Recipes"),(0,n.kt)("h3",{id:"filtering-state-before-sending-it-to-a-client"},"Filtering state before sending it to a client"),(0,n.kt)("p",null,"In your broadcaster, you have control over what the client receives when they request state. You can write a function that filters out any state that the client doesn't have access to."),(0,n.kt)("p",null,"Here, let's filter a ",(0,n.kt)("inlineCode",{parentName:"p"},"playerData")," slice to only include the data of the player that requested state:"),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Server"',title:'"Server"'},"function filterPlayerData(player: Player, state: SharedState) {\n    return {\n        ...state,\n        playerData: {\n            [player.Name]: state.playerData[player.Name],\n        },\n    };\n}\n\n// ...\n\nrequestState.SetCallback((player) => {\n    const state = broadcaster.playerRequestedState(player);\n    return filterPlayerData(player, state);\n});\n"))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Server"',title:'"Server"'},"local function filterPlayerData(player, state)\n    local filteredState = table.clone(state)\n    filteredState.playerData = {\n        [player.Name] = state.playerData[player.Name],\n    }\n    return filteredState\nend\n\n-- ...\n\nrequestState:SetCallback(function(player)\n    local state = broadcaster:playerRequestedState(player)\n    return filterPlayerData(player, state)\nend)\n")))),(0,n.kt)("h3",{id:"filtering-actions-before-sending-them-to-a-player"},"Filtering actions before sending them to a player"),(0,n.kt)("p",null,"You can also filter actions before sending them to a player, which is useful for things like private player data. This is done by modifying the ",(0,n.kt)("inlineCode",{parentName:"p"},"actions")," array in the ",(0,n.kt)("inlineCode",{parentName:"p"},"broadcast")," callback."),(0,n.kt)("p",null,"We'll write a function that only broadcasts player data actions if the first ",(0,n.kt)("inlineCode",{parentName:"p"},"name")," argument of an action is the same as the player that is receiving the action:"),(0,n.kt)(o.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Action filter"',title:'"Action','filter"':!0},"function findPlayerName(args: unknown[]) {\n    // Search for a valid username in the arguments\n    for (const value of args) {\n        if (typeIs(value, \"string\") && Players.FindFirstChild(value)) {\n            return value;\n        }\n    }\n}\n\nfunction createPlayerNameFilter(...actions: { readonly [name: string]: Callback }[]) {\n    const names = new Set<string>();\n\n    // Create a set of all the action names that we want to filter\n    for (const actionMap of actions) {\n        for (const name of Object.keys(actionMap)) {\n            names.add(name);\n        }\n    }\n\n    return (player: Player, actions: BroadcastAction[]) => {\n        // Filter out actions if they are a player data action and this\n        // player isn't the target\n        return actions.filter((action) => {\n            // If the action name isn't in the set, keep it\n            if (!names.has(action.name)) {\n                return true;\n            }\n\n            // Search for a valid username in the arguments\n            const name = findPlayerName(action.arguments);\n\n            // If the action doesn't have a valid username, keep it\n            // Otherwise, only keep the action if the username matches\n            return name === undefined || name === player.Name;\n        });\n    };\n}\n\nconst playerDataFilter = createPlayerNameFilter(playerDataSlice.getActions());\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Server"',title:'"Server"'},'const broadcast = remotes.Server.Get("broadcast");\n\nconst broadcaster = createBroadcaster({\n    producers: sharedSlices,\n    broadcast: (players, actions) => {\n        for (const player of players) {\n            // highlight-next-line\n            const filteredActions = playerDataFilter(player, actions);\n            broadcast.SendToPlayer(player, filteredActions);\n        }\n    },\n});\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Action filter"',title:'"Action','filter"':!0},"local function findPlayerName(args: { any })\n    -- Search for a valid username in the arguments\n    for _, value in args do\n        if type(value) == \"string\" and Players:FindFirstChild(value) then\n            return value\n        end\n    end\nend\n\nlocal function createPlayerNameFilter(...: { [string]: (...any) -> any })\n    local names: { [string]: boolean } = {}\n\n    -- Create a set of all the action names that we want to filter\n    for _, actionMap in { ... } do\n        for name in actionMap do\n            names[name] = true\n        end\n    end\n\n    return function(player, actions)\n        local filteredActions = {}\n\n        -- Filter out actions if they are a player data action and this\n        -- player isn't the target\n        for _, action in actions do\n            -- If the action name isn't in the set, keep it\n            if not names[action.name] then\n                table.insert(filteredActions, action)\n                continue\n            end\n\n            -- Search for a valid username in the arguments\n            local name = findPlayerName(action.arguments)\n\n            -- If the action doesn't have a valid username, keep it\n            -- Otherwise, only keep the action if the username matches\n            if name == nil or name == player.Name then\n                table.insert(filteredActions, action)\n            end\n        end\n\n        return filteredActions\n    end\nend\n\nlocal playerDataFilter = createPlayerNameFilter(playerDataSlice:getActions())\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Server"',title:'"Server"'},'local broadcast = remotes.Server:Get("broadcast")\n\nlocal broadcaster = Reflex.createBroadcaster({\n    producers = sharedSlices,\n    broadcast = function(players, actions)\n        for _, player in players do\n            local filteredActions = playerDataFilter(player, actions)\n            broadcast:SendToPlayer(player, filteredActions)\n        end\n    end,\n})\n')))),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"You can rewrite the ",(0,n.kt)("inlineCode",{parentName:"p"},"findPlayerName")," function to be more specific to your use case. For example, if you want to filter by user ID instead of username, you can use ",(0,n.kt)("inlineCode",{parentName:"p"},"Players.GetPlayerByUserId")," instead of ",(0,n.kt)("inlineCode",{parentName:"p"},"Players.FindFirstChild"),".")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"summary"},"Summary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Shared state is synced between the server and client using a broadcaster and a receiver."),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"broadcaster")," is responsible for sending state and actions to the receiver."),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("strong",{parentName:"li"},"receiver")," is responsible for dispatching actions from the broadcaster.")))}h.isMDXComponent=!0}}]);