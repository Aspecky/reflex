"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[992],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(i,".").concat(m)]||d[m]||p[m]||l;return n?a.createElement(f,s(s({ref:t},u),{},{components:n})):a.createElement(f,s({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=m;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<l;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7233:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(9496),r=n(5924);const l={tabItem:"tabItem_Z2jM"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,s),hidden:n},t)}},5297:(e,t,n)=>{n.d(t,{Z:()=>T});var a=n(8028),r=n(9496),l=n(5924),s=n(1729),o=n(3442),i=n(5968),c=n(9458),u=n(371);function d(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function h(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=p(e),[s,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[i,c]=f({queryString:n,groupId:a}),[d,h]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),g=(()=>{const e=i??d;return m({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{g&&o(g)}),[g]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),h(e)}),[c,h,l]),tabValues:l}}var g=n(6489);const k={tabList:"tabList_Vrhz",tabItem:"tabItem_kl51"};function v(e){let{className:t,block:n,selectedValue:o,selectValue:i,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==o&&(d(t),i(a))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:p},s,{className:(0,l.Z)("tabs__item",k.tabItem,s?.className,{"tabs__item--active":o===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function y(e){const t=h(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",k.tabList)},r.createElement(v,(0,a.Z)({},e,t)),r.createElement(b,(0,a.Z)({},e,t)))}function T(e){const t=(0,g.Z)();return r.createElement(y,(0,a.Z)({key:String(t)},e))}},3443:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var a=n(8028),r=(n(9496),n(9613)),l=n(5297),s=n(7233);const o={description:"Learn how to dispatch actions and run side effects in Reflex."},i="Using Selectors",c={unversionedId:"guides/using-selectors",id:"guides/using-selectors",title:"Using Selectors",description:"Learn how to dispatch actions and run side effects in Reflex.",source:"@site/docs/guides/using-selectors.md",sourceDirName:"guides",slug:"/guides/using-selectors",permalink:"/reflex/docs/guides/using-selectors",draft:!1,tags:[],version:"current",frontMatter:{description:"Learn how to dispatch actions and run side effects in Reflex."},sidebar:"learnSidebar",previous:{title:"Organizing Producers",permalink:"/reflex/docs/guides/organizing-producers"},next:{title:"Subscribing to State",permalink:"/reflex/docs/guides/subscribing-to-state"}},u={},d=[{value:"Selecting state",id:"selecting-state",level:2},{value:"Pitfall: creating objects in selectors",id:"pitfall-creating-objects-in-selectors",level:3},{value:"Transforming state",id:"transforming-state",level:2},{value:"Memoization",id:"memoization",level:3},{value:"Recipes",id:"recipes",level:2},{value:"Passing arguments to selectors",id:"passing-arguments-to-selectors",level:3},{value:"Custom equality checks",id:"custom-equality-checks",level:3},{value:"Equality of dependencies",id:"equality-of-dependencies",level:4},{value:"Equality of results",id:"equality-of-results",level:4},{value:"Summary",id:"summary",level:2}],p={toc:d},m="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-selectors"},"Using Selectors"),(0,r.kt)("p",null,"Games often have complex interactions between different parts of the state. Producers let you subscribe to state changes with ",(0,r.kt)("em",{parentName:"p"},"selectors"),"."),(0,r.kt)("admonition",{title:"what you'll learn",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"\ud83c\udf70 How to write selectors"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd10 When to memoize selectors"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd25 How to write more powerful selectors"))),(0,r.kt)("h2",{id:"selecting-state"},"Selecting state"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Selectors")," are functions that take the root state and return a subset of it. They can be as simple as indexing a property, or as complex as filtering and transforming data. We'll go over some examples of selectors, and different ways to use them."),(0,r.kt)("p",null,"Let's say we had this ",(0,r.kt)("inlineCode",{parentName:"p"},"calendar")," slice in our root state, and we wanted to print out all the events in the calendar:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const calendarSlice = createProducer(initialState, {\n    addEvent: (state, event: CalendarEvent) => ({\n        ...state,\n        events: [...state.events, event],\n    }),\n});\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local calendarSlice = Reflex.createProducer(initialState, {\n    addEvent = function(state: CalendarState, event: CalendarEvent): CalendarState\n        local nextState = table.clone(state)\n        local nextEvents = table.clone(state.events)\n\n        table.insert(nextEvents, event)\n        nextState.events = nextEvents\n\n        return nextState\n    end,\n})\n")))),(0,r.kt)("p",null,"With ",(0,r.kt)("strong",{parentName:"p"},"selectors"),", we can write a function that returns the events from the calendar, and use it to get the events from the root state:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectEvents = (state: RootState) => {\n    return state.calendar.events;\n};\n\nfor (const event of producer.getState(selectEvents)) {\n    print(`${event.name} (${event.date})`);\n}\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\nfor _, event in producer:getState(selectEvents) do\n    print("- " .. event.name .. " (" .. event.date .. ")")\nend\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Birthday (2004-12-27)\n# Learn Reflex (2023-03-17)\n")),(0,r.kt)("p",null,"Or, if you want to run code when the selector's value changes, you can ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," to it:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.subscribe(selectEvents, (events) => {\n    for (const event of events) {\n        print(`${event.name} (${event.date})`);\n    }\n});\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer:subscribe(selectEvents, function(events)\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n')))),(0,r.kt)("h3",{id:"pitfall-creating-objects-in-selectors"},"Pitfall: creating objects in selectors"),(0,r.kt)("p",null,"In the previous examples, the ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEvents")," selector is simple and returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," property of the calendar slice. But what if you want to get the events sorted by date? Your first thought might be to write a selector like this:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectEventsByTime = (state: RootState) => {\n    // error-next-line\n    // \ud83d\udd34 This creates a new array every time the selector is called\n    // error-next-line\n    return table.clone(state.calendar.events).sort((a, b) => {\n        const timeA = DateTime.fromIsoDate(a.date);\n        const timeB = DateTime.fromIsoDate(b.date);\n        return timeA.UnixTimestamp < timeB.UnixTimestamp;\n    });\n};\n\nfor (const date of producer.getState(selectEventsByTime)) {\n    print(`${date.date} - ${date.name}`);\n}\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectEventsByTime(state: producer.RootState)\n    // error-next-line\n    -- \ud83d\udd34 This creates a new array every time the selector is called\n    // error-next-line\n    local events = table.clone(state.calendar.events)\n\n    table.sort(events, function(a, b)\n        local timeA = DateTime.fromIsoDate(a.date)\n        local timeB = DateTime.fromIsoDate(b.date)\n        return timeA.UnixTimestamp < timeB.UnixTimestamp\n    end)\n\n    return events\nend\n\nfor _, date in producer:getState(selectEventsByTime) do\n    print(date.date .. " - " .. date.name)\nend\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# 2004-12-27 - Birthday\n# 2023-03-17 - Learn Reflex\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This code works, but there's a catch.")," Every time you call ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime"),", it will create a new array! And by returning a new value that isn't equal to the last one, you're telling Reflex that the value changed, even if it has the same contents. This can cause problems when you try to ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," to the selector:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'producer.subscribe(selectEventsByTime, (events) => {\n    print("events changed!");\n});\n\n// highlight-next-line\nproducer.addTodo("Unrelated todo");\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer:subscribe(selectEventsByTime, function(events)\n    print("events changed!")\nend)\n\n// highlight-next-line\nproducer.addTodo("Unrelated todo")\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# error-next-line\n# events changed!\n")),(0,r.kt)("p",null,"Oh no! We added a ",(0,r.kt)("strong",{parentName:"p"},"todo item"),", which is in an unrelated part of the state, but it still thinks that our sorted events changed! We'll go over how to fix this in the ",(0,r.kt)("a",{parentName:"p",href:"#transforming-state"},"next section"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"transforming-state"},"Transforming state"),(0,r.kt)("p",null,"Right now, our ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime")," selector creates a new array ",(0,r.kt)("strong",{parentName:"p"},"every time")," it is called. This is a problem because Reflex runs our selector on ",(0,r.kt)("em",{parentName:"p"},"every")," state change, and detects state updates by ",(0,r.kt)("strong",{parentName:"p"},"strict equality")," (",(0,r.kt)("inlineCode",{parentName:"p"},"==="),"). If the selector's new value is different from what it returned last time, it will call the listener."),(0,r.kt)("p",null,"But if we also can't sort the original array because ",(0,r.kt)("a",{parentName:"p",href:"#immutable-state-and-actions"},"state is immutable"),", what can we do to transform state?"),(0,r.kt)("h3",{id:"memoization"},"Memoization"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Memoization")," is a technique that can be used to ",(0,r.kt)("strong",{parentName:"p"},"cache")," the result of a function. If the function is called with the same arguments, the cached result can be returned instead of recalculating it."),(0,r.kt)("p",null,"If we memoize our ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime")," selector, it will only create a new array when the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," property changes, fixing the problem we had before."),(0,r.kt)("p",null,"Reflex exports the ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," function to create memoized selectors:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector } from "@rbxts/reflex";\n\nconst selectEvents = (state: RootState) => state.calendar.events;\n\n// highlight-next-line\nconst selectEventsByTime = createSelector(selectEvents, (events) => {\n    return [...events].sort((a, b) => {\n        const timeA = DateTime.fromIsoDate(a.date);\n        const timeB = DateTime.fromIsoDate(b.date);\n        return timeA.UnixTimestamp < timeB.UnixTimestamp;\n    });\n});\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\n// highlight-next-line\nlocal selectEventsByTime = Reflex.createSelector(selectEvents, function(events)\n    local events = table.clone(events)\n\n    table.sort(events, function(a, b)\n        local timeA = DateTime.fromIsoDate(a.date)\n        local timeB = DateTime.fromIsoDate(b.date)\n        return timeA.UnixTimestamp < timeB.UnixTimestamp\n    end)\n\n    return events\nend)\n")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"You'd pass two type of values to ",(0,r.kt)("a",{parentName:"strong",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")),":")),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"dependencies"),", the selectors whose results will be passed to the ",(0,r.kt)("inlineCode",{parentName:"li"},"combiner")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"combiner"),", a function that takes the results of the ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," and returns a new state")),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," won't run unless the dependencies and arguments change, so it's safer to do expensive operations and return new objects in it."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},"Read more about ",(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")," \u2192"))),(0,r.kt)("p",null,"With our new ",(0,r.kt)("strong",{parentName:"p"},"memoized")," selector, the listener will only be called when the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," dependency changes:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'producer.subscribe(selectEventsByTime, (events) => {\n    print("events changed!");\n});\n\n// \u2705 Will not call the listener\nproducer.addTodo("Unrelated todo");\n\ntask.wait(1);\n\nproducer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer:subscribe(selectEventsByTime, function(events)\n    print("events changed!")\nend)\n\n-- \u2705 Will not call the listener\nproducer.addTodo("Unrelated todo")\n\ntask.wait(1)\n\nproducer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# events changed!\n")),(0,r.kt)("p",null,"Now, we can subscribe to an automatically-sorted list of events efficiently!"),(0,r.kt)("p",null,"Using selectors this way allows you to ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector#transforming-state"},"derive new information")," from state while keeping your producers and slices simple. This is a common pattern when using Rodux, and it's a good idea to use it in Reflex too."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Memoizing selectors is a good idea, but it's not always necessary.")," You should prefer to memoize selectors that are expensive or return new objects; indexing a table or returning a primitive value is cheap and doesn't need to be memoized.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"recipes"},"Recipes"),(0,r.kt)("h3",{id:"passing-arguments-to-selectors"},"Passing arguments to selectors"),(0,r.kt)("p",null,"Often, you may want to pass arguments to a selector. For example, you may want to select a specific calendar event by its name. There are two main ways to do this:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"../reference/reflex/create-selector#selector-factories"},"Selector factories")," that return a selector function for a given set of arguments"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"../reference/reflex/create-selector#dependency-currying"},"Currying")," arguments by adding them to the ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," array")),(0,r.kt)("p",null,"There are pros and cons to each approach, but we'll only cover selector factories because they're more ergonomic."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("strong",{parentName:"p"},"selector factory")," that returns a selector function for a given event name:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector } from "@rbxts/reflex";\n\nconst selectEvents = (state: RootState) => state.calendar.events;\n\n// highlight-next-line\nconst selectEventByName = (name: string) => {\n    return createSelector(selectEvents, (events) => {\n        return events.find((event) => event.name === name);\n    });\n};\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\n// highlight-next-line\nlocal function selectEventByName(name: string)\n    return Reflex.createSelector(selectEvents, function(events)\n        for _, event in events do\n            if event.name == name then\n                return event\n            end\n        end\n    end)\nend\n")))),(0,r.kt)("p",null,"With our new selector factory, we can create a selector for a specific event:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// highlight-next-line\nconst selectBirthday = selectEventByName("Birthday");\n\nproducer.subscribe(selectBirthday, (event) => {\n    print(`Birthday is on ${event.date}`);\n});\n\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'// highlight-next-line\nlocal selectBirthday = selectEventByName("Birthday")\n\nproducer:subscribe(selectBirthday, function(event)\n    print("Birthday is on " .. event.date)\nend)\n\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Birthday is on 2004-12-27\n")),(0,r.kt)("p",null,"Selector factories are a nice and simple way to create selectors specialized for a given set of arguments. This pattern can be used to create selectors for a specific user, apply a sort filter, or any other transformation that depends on external arguments."),(0,r.kt)("h3",{id:"custom-equality-checks"},"Custom equality checks"),(0,r.kt)("p",null,"By default, ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," uses a strict equality check to compare the results of the dependencies and determine whether to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner"),". This is usually fine, but sometimes you may want to use a custom equality check."),(0,r.kt)("h4",{id:"equality-of-dependencies"},"Equality of dependencies"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," accepts an optional third argument, ",(0,r.kt)("inlineCode",{parentName:"p"},"options"),", which can be used to customize the behavior of the selector. One of the options is ",(0,r.kt)("inlineCode",{parentName:"p"},"equalityCheck"),", which can be used to specify a custom equality check."),(0,r.kt)("p",null,"For example, if you want to only run the ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," if the dependencies are not shallowly equal, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"shallowEqual")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"equalityCheck"),":"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector, shallowEqual } from "@rbxts/reflex";\n\nconst selectTodos = createSelector(\n    selectTodoIds,\n    (ids) => {\n        for (const _ of $range(0, 10000)) {\n            // some expensive operation\n        }\n    },\n    // highlight-next-line\n    { equalityCheck: shallowEqual },\n);\n\nselectTodos(table.clone(state)) === selectTodos(table.clone(state)); // true\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal selectTodos = Reflex.createSelector(selectTodoIds, function(ids)\n    for i = 1, 10000 do\n        -- some expensive operation\n    end\nend, {\n    // highlight-next-line\n    equalityCheck = Reflex.shallowEqual,\n})\n\nselectTodos(table.clone(state)) == selectTodos(table.clone(state)) -- true\n")))),(0,r.kt)("h4",{id:"equality-of-results"},"Equality of results"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"options")," argument also accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"resultEqualityCheck"),' option, which is used to prevent returning a new value unless the result is not "equal" to the previous value. This is useful when the ',(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," returns a new object every time it's called, but the result is actually the same."),(0,r.kt)("p",null,"For example, if you want to only return a new object if the ",(0,r.kt)("inlineCode",{parentName:"p"},"todos")," array has changed, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"shallowEqual")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"resultEqualityCheck"),":"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector, shallowEqual } from "@rbxts/reflex";\n\nconst selectTodoIds = createSelector(\n    selectTodos,\n    (todos) => {\n        return todos.map((todo) => todo.id);\n    },\n    // highlight-next-line\n    { resultEqualityCheck: shallowEqual },\n);\n\nselectTodos(table.clone(state)) === selectTodos(table.clone(state)); // true\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal selectTodoIds = Reflex.createSelector(selectTodos, function(todos)\n    local ids = {}\n\n    for _, todo in todos do\n        table.insert(ids, todo.id)\n    end\n\n    return ids\nend, {\n    // highlight-next-line\n    resultEqualityCheck = Reflex.shallowEqual,\n})\n\nselectTodos(table.clone(state)) == selectTodos(table.clone(state)) -- true\n")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can update the state of a producer by calling ",(0,r.kt)("strong",{parentName:"li"},"actions"),"."),(0,r.kt)("li",{parentName:"ul"},"You can ",(0,r.kt)("strong",{parentName:"li"},"subscribe")," to a producer to listen for state changes."),(0,r.kt)("li",{parentName:"ul"},"You can create ",(0,r.kt)("strong",{parentName:"li"},"selectors")," to select a subset of the state and listen for changes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Memoizing")," selectors can improve performance and reduce redundant updates."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Selector factories")," can be used to create selectors that depend on external arguments."),(0,r.kt)("li",{parentName:"ul"},"Selector factories can hold their own ",(0,r.kt)("strong",{parentName:"li"},"state"),".")))}f.isMDXComponent=!0}}]);