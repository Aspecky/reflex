"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[74],{5558:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>k,frontMatter:()=>o,metadata:()=>u,toc:()=>d});var a=n(1966),r=(n(9496),n(9613)),l=n(7934),i=n(4575),s=n(5488);const o={sidebar_position:2,description:"Manage your game's state with producers."},p="Producer",u={unversionedId:"reference/reflex/producer",id:"reference/reflex/producer",title:"Producer",description:"Manage your game's state with producers.",source:"@site/docs/reference/reflex/producer.md",sourceDirName:"reference/reflex",slug:"/reference/reflex/producer",permalink:"/reflex/docs/reference/reflex/producer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Manage your game's state with producers."},sidebar:"referenceSidebar",previous:{title:"createProducer",permalink:"/reflex/docs/reference/reflex/create-producer"},next:{title:"combineProducers",permalink:"/reflex/docs/reference/reflex/combine-producers"}},c={},d=[{value:"Reference",id:"reference",level:2},{value:"<code>action</code> functions",id:"action-functions",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"<code>getState(selector?)</code>",id:"getstateselector",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"<code>subscribe(selector?, predicate?, listener)</code>",id:"subscribeselector-predicate-listener",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"<code>once(selector, predicate?, listener)</code>",id:"onceselector-predicate-listener",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"<code>wait(selector, predicate?)</code>",id:"waitselector-predicate",level:3},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-4",level:4},{value:"<code>observe(selector, discriminator?, observer)</code>",id:"observeselector-discriminator-observer",level:3},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-5",level:4},{value:"<code>flush()</code>",id:"flush",level:3},{value:"<code>applyMiddleware(...middlewares)</code>",id:"applymiddlewaremiddlewares",level:3},{value:"Parameters",id:"parameters-6",level:4},{value:"Returns",id:"returns-6",level:4},{value:"Usage",id:"usage",level:2},{value:"Running side effects",id:"running-side-effects",level:3},{value:"Waiting for state changes",id:"waiting-for-state-changes",level:3},{value:"Transforming state with selectors",id:"transforming-state-with-selectors",level:3},{value:"Using the observer pattern",id:"using-the-observer-pattern",level:3},{value:"Using middleware",id:"using-middleware",level:3},{value:"Using multiple producers",id:"using-multiple-producers",level:3}],m={toc:d},h="wrapper";function k(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"producer"},"Producer"),(0,r.kt)("p",null,"A producer is a state container with built-in functions to update state and run side effects. To create one, use ",(0,r.kt)("a",{parentName:"p",href:"create-producer"},(0,r.kt)("inlineCode",{parentName:"a"},"createProducer")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(initialState, actions);\n")),(0,r.kt)(s.Z,{toc:d,mdxType:"TOCInline"}),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("h3",{id:"action-functions"},(0,r.kt)("inlineCode",{parentName:"h3"},"action")," functions"),(0,r.kt)("p",null,"Actions are functions that update the producer's state. They are created by passing an object of action functions to ",(0,r.kt)("a",{parentName:"p",href:"create-producer"},(0,r.kt)("inlineCode",{parentName:"a"},"createProducer")),"."),(0,r.kt)("p",null,"You can dispatch an action by calling it on the producer:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(0, {\n    increment: (state, value: number) => state + value,\n});\n\n// highlight-next-line\nproducer.increment(1); // 1\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local producer = Reflex.createProducer(0, {\n    increment = function(state, value: number): number\n        return state + value\n    end,\n})\n\n// highlight-next-line\nproducer.increment(1) --\x3e 1\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"create-producer#updating-state-with-actions"},"See how to create actions here.")),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"...args")," - The parameters to pass to the action function.")),(0,r.kt)("h4",{id:"returns"},"Returns"),(0,r.kt)("p",null,"Dispatching returns the new state of the producer."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getstateselector"},(0,r.kt)("inlineCode",{parentName:"h3"},"getState(selector?)")),(0,r.kt)("p",null,"Producers allow you to access the current state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"getState"),". You can optionally pass a selector function to ",(0,r.kt)("inlineCode",{parentName:"p"},"getState")," to select a specific part of the state."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.getState(); // { count: 0 }\nproducer.getState((state) => state.count); // 0\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer:getState() --\x3e { count = 0 }\nproducer:getState(function(state)\n    return state.count\nend) --\x3e 0\n")))),(0,r.kt)("h4",{id:"parameters-1"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," - A function that selects a part of the state. If not provided, the entire state is returned.")),(0,r.kt)("h4",{id:"returns-1"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getState")," returns the current state of the producer, or the result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"selector")," if one is provided."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"h3"},"subscribe(selector?, predicate?, listener)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," method lets you listen for changes to the producer's state. Generally, you should pass a selector function to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," to only listen for changes to a subset of the state."),(0,r.kt)("p",null,"To unsubscribe from a listener, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),"."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectCount = (state: State) => state.count;\n\nconst unsubscribe = producer.subscribe(selectCount, (count, prevCount) => {\n    print(count, prevCount);\n});\n\nproducer.increment(1); // 1, 0\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectCount(state)\n    return state.count\nend\n\nlocal unsubscribe = producer:subscribe(selectCount, function(count, prevCount)\n    print(count, prevCount)\nend)\n\nproducer.increment(1) --\x3e 1, 0\n")))),(0,r.kt)("p",null,"You may optionally pass a predicate function to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," to only listen for changes that match a certain condition. If the predicate is provided, the listener will only be called if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectCount = (state: State) => state.count;\n\nconst isEven = (count: number) => count % 2 === 0;\n\nproducer.subscribe(selectCount, isEven, (count, prevCount) => {\n    print(count, prevCount);\n});\n\nproducer.increment(1);\nproducer.increment(1); // 2, 0\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectCount(state)\n    return state.count\nend\n\nlocal function isEven(count: number)\n    return count % 2 == 0\nend\n\nproducer:subscribe(selectCount, isEven, function(count, prevCount)\n    print(count, prevCount)\nend)\n\nproducer.increment(1)\nproducer.increment(1) --\x3e 2, 0\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#running-side-effects"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-2"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state. If not provided, the entire state is passed to the listener.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," - A function that determines whether the listener should be called. If not provided, the listener will always be called.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"listener")," - A function that is called when the state changes. The function receives the state as its first argument, and the previous state as its second argument."))),(0,r.kt)("h4",{id:"returns-2"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," returns a function that can be called to unsubscribe the listener."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you pass a selector to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),", the listener will only be called once the selector returns a new value. Changes are compared ",(0,r.kt)("strong",{parentName:"p"},"by reference (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),")"),", so if your selector creates a new object, remember to ",(0,r.kt)("a",{parentName:"p",href:"create-selector"},"memoize it with ",(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"State updates within a ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," event should only be done in response to a selected state or under certain conditions. Otherwise, you may end up in an infinite loop.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Listeners are called synchronously ",(0,r.kt)("strong",{parentName:"p"},"on the frame after an action is dispatched"),". This means that if you dispatch multiple actions in the same frame, listeners will only be called once with the final state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Similar to Redux, if you subscribe, unsubscribe, or change state while a listener is being called, the changes will not affect the current dispatch. However, they will affect the next dispatch.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"h3"},"once(selector, predicate?, listener)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"once")," lets you listen for a single change to the producer's state. It works similarly to ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),", but the listener is automatically unsubscribed after the first call. If the predicate is provided, the listener will only be called if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,"To unsubscribe from a listener, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"once"),"."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCounter = (state: State) => state.count;\n\nconst isGreaterThanOne = (count: number) => count > 1;\n\nproducer.once(selectCounter, isGreaterThanOne, (count, prevCount) => {\n    print(count, "is greater than 1");\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCounter(state)\n    return state.count\nend\n\nlocal function isGreaterThanOne(count)\n    return count > 1\nend\n\nproducer:once(selectCounter, isGreaterThanOne, function(count, prevCount)\n    print(count, "is greater than 1")\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-3"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," - A function that determines whether the listener should be called. If not provided, the listener will be called once the selected state changes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"listener")," - A function that is called when the state changes. The function receives the new state as its first argument, and the state from the time of subscription as its second argument."))),(0,r.kt)("h4",{id:"returns-3"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"once")," returns a function that can be called to unsubscribe the listener."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"once")," has the ",(0,r.kt)("a",{parentName:"p",href:"#caveats"},"same caveats")," as ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at the time of subscription, the listener ",(0,r.kt)("strong",{parentName:"p"},"will not")," be called immediately. It will only be called once the selected state changes, and only if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at that time. This behavior is analogous to ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise.fromEvent")," and how it waits for the ",(0,r.kt)("em",{parentName:"p"},"next")," event.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"h3"},"wait(selector, predicate?)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wait")," returns a promise that resolves once the selected state changes. If the predicate is provided, the promise will only resolve if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,"To unsubscribe from a listener, cancel the promise returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"wait"),"."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCounter = (state: State) => state.count;\n\nconst isGreaterThanOne = (count: number) => count > 1;\n\nproducer.wait(selectCounter, isGreaterThanOne).then((count) => {\n    print(count, "is greater than 1");\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCounter(state)\n    return state.count\nend\n\nlocal function isGreaterThanOne(count)\n    return count > 1\nend\n\nproducer:wait(selectCounter, isGreaterThanOne):andThen(function(count)\n    print(count, "is greater than 1")\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-4"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," - A function that determines whether the promise should resolve. If not provided, the promise will resolve once the selected state changes."))),(0,r.kt)("h4",{id:"returns-4"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wait")," returns a promise that resolves once the selected state changes ",(0,r.kt)("em",{parentName:"p"},"and")," the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"wait")," has the ",(0,r.kt)("a",{parentName:"p",href:"#caveats"},"same caveats")," as ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at the time ",(0,r.kt)("inlineCode",{parentName:"p"},"wait")," is called, the Promise ",(0,r.kt)("strong",{parentName:"p"},"will not")," resolve immediately. It will only be resolve once the selected state changes, and only if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at that time. This behavior is analogous to ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise.fromEvent")," and how it waits for the ",(0,r.kt)("em",{parentName:"p"},"next")," event.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"h3"},"observe(selector, discriminator?, observer)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"observe")," lets you track the addition and removal of a ",(0,r.kt)("strong",{parentName:"p"},"unique item")," in the producer's state. The selector may return an array or a record of items. When an item is added, the Observer is called with the item, and cleaned up when the item is removed."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"discriminator")," is used to differentiate between items. If the discriminator is not provided, the item is tracked by its reference in the record. If the discriminator is provided, the item is tracked by the result of the discriminator."),(0,r.kt)("p",null,"To unsubscribe from an Observer, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"observe"),"."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectTodos = (state: State) => state.todos;\n\nconst identifyTodo = (todo: Todo) => todo.id;\n\nproducer.observe(selectTodos, identifyTodo, (todo) => {\n    print(todo, "was added");\n\n    return () => {\n        print(todo, "was removed");\n    };\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectTodos(state)\n    return state.todos\nend\n\nlocal function identifyTodo(todo)\n    return todo.id\nend\n\nproducer:observe(selectTodos, identifyTodo, function(todo)\n    print(todo, "was added")\n\n    return function()\n        print(todo, "was removed")\n    end\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#using-the-observer-pattern"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-5"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"discriminator")," - A function that returns a unique identifier for an item. If not provided, the item is tracked by its reference in the record.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"observer")," - Called when an item is added to the record. It returns an optional cleanup function that is called when the item is removed from the state."))),(0,r.kt)("h4",{id:"returns-5"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"observe")," returns a function that can be called to unsubscribe from the state and clean up all Observers."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Passing a discriminator is highly recommended when tracking unique objects.")," This is because immutable objects are compared by reference. If you pass a record of objects without a discriminator, the Observer will be called every time an object is updated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The discriminator must return a unique value for each item.")," If two items have the same discriminator, Observers will track the first to be added or removed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Observer is called immediately for each item in the initial state.")," This means that if the state is already populated with items, the Observer will be called for each item.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The first argument of the Observer is the item that was added.")," It acts as an initial state and ",(0,r.kt)("strong",{parentName:"p"},"does not update")," when the item is updated.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"flush"},(0,r.kt)("inlineCode",{parentName:"h3"},"flush()")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"flush")," method is used to immediately run a scheduled update. This is useful for forcing an update to run synchronously, but should generally be avoided."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.flush();\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer:flush()\n")))),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"flush")," should not be called during a state update. Doing so might cause unexpected behavior."))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"applymiddlewaremiddlewares"},(0,r.kt)("inlineCode",{parentName:"h3"},"applyMiddleware(...middlewares)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," method is used to apply middleware to the producer. Middleware can be used to enhance producers, dispatch actions, or perform side effects."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const loggerMiddleware: ProducerMiddleware = (producer) => {\n    print("initial state:", producer.getState());\n\n    producer.subscribe((state) => {\n        print("next state:", state);\n    });\n\n    return (dispatch, name) => {\n        return (...args) => {\n            print(`dispatching ${name}:`, ...args);\n            return dispatch(...args);\n        };\n    };\n};\n\nproducer.applyMiddleware(loggerMiddleware);\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local loggerMiddleware: Reflex.Middleware = function(producer)\n    print("initial state:", producer:getState())\n\n    producer:subscribe(function(state)\n        print("next state:", state)\n    end)\n\n    return function(dispatch, name)\n        return function(...)\n            print("dispatching", name, ...)\n            return dispatch(...)\n        end\n    end\nend\n\nproducer:applyMiddleware(loggerMiddleware)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#using-middleware"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-6"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"...middlewares")," - A list of middleware functions. The middleware functions are called in the order they are provided.")),(0,r.kt)("h4",{id:"returns-6"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," returns the original producer."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Middleware functions have ",(0,r.kt)("strong",{parentName:"p"},"three layers")," of abstraction: the producer, the dispatch function, and individual dispatches. The producer is the ",(0,r.kt)("strong",{parentName:"p"},"highest level of abstraction")," and is called once when applying the middleware. The dispatch function is the ",(0,r.kt)("strong",{parentName:"p"},"middle layer of abstraction")," and called with the dispatch functions in the producer. The individual dispatches are the ",(0,r.kt)("strong",{parentName:"p"},"lowest level of abstraction")," and run before each dispatch.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Middleware functions are called in the order they are provided.")," This means that middleware functions that depend on other middleware functions should be provided after their dependencies.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The return value matters!")," Middleware functions can intercept dispatches and make them return a value other than the new state. If a middleware function returns a value, the next middleware function will receive that value, and eventually will be returned by the dispatch function.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"running-side-effects"},"Running side effects"),(0,r.kt)("p",null,"Games have a lot of state that changes over time, and you often need to perform ",(0,r.kt)("em",{parentName:"p"},"side effects")," for certain state updates. Let's first look at how to subscribe to state changes, and then we'll cover some use cases."),(0,r.kt)("p",null,"You can use ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," to connect a listener function that runs whenever a certain part of the state changes:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCount = (state: State) => state.count;\n\nproducer.subscribe(selectCount, (count) => {\n    print("count changed:", count);\n});\n\nproducer.increment(10); // count changed: 10\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCount(state)\n    return state.count\nend\n\nproducer:subscribe(selectCount, function(count, prevCount)\n    print("count changed:", count)\nend)\n\nproducer.increment(10) --\x3e count changed: 10\n')))),(0,r.kt)("p",null,"The listener runs whenever the value given by ",(0,r.kt)("inlineCode",{parentName:"p"},"selectCount")," changes. Once the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action is dispatched, the listener will output the new value of ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," on the next tick."),(0,r.kt)("p",null,"You pass two parameters to the ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," method:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("em",{parentName:"li"},"selector")," that returns a subset of the state you want to subscribe to."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("em",{parentName:"li"},"listener")," to call when the state changes.")),(0,r.kt)("p",null,"Once you have subscribed to the state you want, you can safely run side effects in the listener function. For example, you play a damage sound when a player gets hurt."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Say you have a game where the player's health is stored in the state:")),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface RootState {\n    readonly health: number;\n}\n\nconst initialState: RootState = {\n    health: 100,\n};\n\nconst producer = createProducer(initialState, {\n    takeDamage: (state, health: number) => ({\n        ...state,\n        health: state.health - health,\n    }),\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type RootState = {\n    health: number,\n}\n\ntype RootActions = {\n    takeDamage: (health: number) -> (),\n}\n\nlocal initialState = {\n    health = 100,\n}\n\nlocal producer = createProducer(initialState, {\n    takeDamage = function(state, health)\n        local nextState = table.clone(state)\n        nextState.health -= health\n        return nextState\n    end,\n}) :: Reflex.Producer<RootState, RootActions>\n")))),(0,r.kt)("p",null,"Your producer has an action to deal damage to the player, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," field for the player in the state. You now know how to select the ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," field and subscribe to changes, but how can you play a sound when they ",(0,r.kt)("em",{parentName:"p"},"lose")," health?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"You can do this by checking if the new health is lower than the previous health:")),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectHealth = (state: RootState) => state.health;\n\nproducer.subscribe(selectHealth, (health, prevHealth) => {\n    if (health < prevHealth) {\n        playDamageSound();\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectHealth(state)\n    return state.health\nend\n\nproducer:subscribe(selectHealth, function(health, prevHealth)\n    if health < prevHealth then\n        playDamageSound()\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This code calls the ",(0,r.kt)("inlineCode",{parentName:"strong"},"playDamageSound")," function whenever the player's health decreases.")," If the current health is less than the previous health, the player was hurt, and the sound should play."),(0,r.kt)("p",null,"But what if you want to wait for a specific state change to occur? ",(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"Producers provide methods for that, too!")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"waiting-for-state-changes"},"Waiting for state changes"),(0,r.kt)("p",null,"Sometimes, you want to delay a side effect until a specific state change occurs. Producers offer the ",(0,r.kt)("a",{parentName:"p",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once"))," and ",(0,r.kt)("a",{parentName:"p",href:"#waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"a"},"wait"))," methods to help wait for an event to occur."),(0,r.kt)("p",null,"For example, say your player state also contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"jumping")," boolean that is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," when the player holds down the jump button. You want it to run a ",(0,r.kt)("inlineCode",{parentName:"p"},"jump()")," function in a loop, and disconnect it when it stops. One way to automatically disconnect the loop is with ",(0,r.kt)("a",{parentName:"p",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once")),"."),(0,r.kt)("p",null,"This code starts the loop when ",(0,r.kt)("inlineCode",{parentName:"p"},"jumping")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", and then disconnects the loop when the state changes to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectJumping = (state: RootState) => state.jumping;\n\nconst isFalse = (value: boolean) => value === false;\n\nproducer.subscribe(selectJumping, (jumping) => {\n    if (jumping) {\n        const heartbeat = RunService.Heartbeat.Connect(jump);\n\n        producer.once(selectJumping, isFalse, (jumping) => {\n            heartbeat.Disconnect();\n        });\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectJumping(state)\n    return state.jumping\nend\n\nlocal function isFalse(value)\n    return value == false\nend\n\nproducer:subscribe(selectJumping, function(jumping)\n    if jumping then\n        local heartbeat = RunService.Heartbeat:Connect(jump)\n\n        producer:once(selectJumping, isFalse, function(jumping)\n            heartbeat:Disconnect()\n        end)\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("a",{parentName:"strong",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once"))," method receives three parameters:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," that returns the part of the state you want to subscribe to"),(0,r.kt)("li",{parentName:"ol"},"An optional ",(0,r.kt)("inlineCode",{parentName:"li"},"predicate")," that returns ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," when the state change you are waiting for has occurred"),(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"listener")," that is called when the state has changed")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," parameter is optional. If you pass a predicate, the listener will only be called when the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),". Otherwise, the listener will be called when the selector returns a new value."),(0,r.kt)("p",null,"Producers also provide ",(0,r.kt)("a",{parentName:"p",href:"#waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"a"},"wait")),", a shorthand for ",(0,r.kt)("a",{parentName:"p",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once"))," that returns a promise:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectJumping = (state: RootState) => state.jumping;\n\nconst isFalse = (value: boolean) => value === false;\n\nasync function startJumping() {\n    const heartbeat = RunService.Heartbeat.Connect(jump);\n\n    return producer.wait(selectJumping, isFalse).finally(() => {\n        heartbeat.Disconnect();\n    });\n}\n\nproducer.subscribe(selectJumping, (jumping) => {\n    if (jumping) {\n        startJumping();\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectJumping(state)\n    return state.jumping\nend\n\nlocal function isFalse(value)\n    return value == false\nend\n\nlocal function startJumping()\n    local heartbeat = RunService.Heartbeat:Connect(jump)\n\n    return producer:wait(selectJumping, isFalse):finally(function()\n        heartbeat:Disconnect()\n    end)\nend\n\nproducer:subscribe(selectJumping, function(jumping)\n    if jumping then\n        startJumping()\n    end\nend)\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"transforming-state-with-selectors"},"Transforming state with selectors"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A good rule of thumb is to keep your state as simple as possible.")," This includes avoiding redundant data that can be derived from other parts of the state. However, that might make it harder to perform side effects on your existing state. How can you derive ",(0,r.kt)("em",{parentName:"p"},"new data")," from the state without changing it?"),(0,r.kt)("p",null,"Say your game's state contains a list of players, and each player has a ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," property. If you want to retrieve a list of players that are alive, you can create a ",(0,r.kt)("em",{parentName:"p"},"selector")," that creates a new list of players from the existing state:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectPlayers = (state: RootState) => state.players;\n\nconst selectAlivePlayers = createSelector([selectPlayers] as const, (players) => {\n    return players.filter((player) => player.health > 0);\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectPlayers(state)\n    return state.players\nend\n\nlocal selectAlivePlayers = Reflex.createSelector({ selectPlayers }, function(players)\n    local alivePlayers = {}\n\n    for _, player in players do\n        if player.health > 0 then\n            table.insert(alivePlayers, player)\n        end\n    end\n\n    return alivePlayers\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Using ",(0,r.kt)("a",{parentName:"strong",href:"create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," for deriving new objects is good practice.")," It allows you to ",(0,r.kt)("strong",{parentName:"p"},"memoize")," a selector and cache its results. Note that this is best used when the selector ",(0,r.kt)("strong",{parentName:"p"},"returns a new object")," (mapping, filtering, etc.) or ",(0,r.kt)("strong",{parentName:"p"},"performs a heavy computation"),". A simple table index does not need to be memoized."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"This is because state changes are determined by reference equality (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),").")," If Reflex calls your selector and it always returns a new table, Reflex will think that the state has changed ",(0,r.kt)("strong",{parentName:"p"},"every time")," the selector is called. This can lead to performance issues down the line.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"With this selector, you can subscribe to changes in the list of alive players.")," Your original state hasn't changed, but you can now filter out the players that are alive and perform side effects based on that."),(0,r.kt)("p",null,"For example, you can run some code whenever a player is filtered from the list of alive players:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.subscribe(selectAlivePlayers, (alivePlayers, prevAlivePlayers) => {\n    for (const player of prevAlivePlayers) {\n        const stillAlive = alivePlayers.some((p) => p.id === player.id);\n\n        if (!stillAlive) {\n            playerDied(player);\n        }\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function hasPlayer(players, id)\n    for _, player in players do\n        if player.id == id then\n            return true\n        end\n    end\n\n    return false\nend\n\nproducer:subscribe(selectAlivePlayers, function(alivePlayers, prevAlivePlayers)\n    for _, player in prevAlivePlayers do\n        if not hasPlayer(alivePlayers, player.id) then\n            playerDied(player)\n        end\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"But finding differences between lists can quickly get cumbersome.")," What if you want to track the health of a specific player? Or what if you want to clean up some state when a player dies?"),(0,r.kt)("p",null,"This is where the ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," method comes in handy. ",(0,r.kt)("a",{parentName:"p",href:"#using-the-observer-pattern"},"See how to use it in the next section.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"using-the-observer-pattern"},"Using the observer pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Game state often contains many lists and records of data.")," You will likely need to run code when a new item is added to a record, or clean something up when the item is removed. We'll explore Observers, their use cases, and using ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"[]",(0,r.kt)("inlineCode",{parentName:"strong"},"observe"),"](#observeselector-discriminator-observer) brings the ",(0,r.kt)("a",{parentName:"strong",href:"https://sleitnick.github.io/RbxObservers/docs/observer-pattern"},"Observer pattern")," to Reflex.")," Some good use cases for ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Managing matches in a multiplayer game"),(0,r.kt)("li",{parentName:"ul"},"Spawning players and cleaning up when they die or leave the game"),(0,r.kt)("li",{parentName:"ul"},"Applying temporary status effects")),(0,r.kt)("p",null,"Let's say your state has a list of players, and each player has a ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," property. You want to play a sound whenever a player is damaged or dies. To help track individual players, you should first create a ",(0,r.kt)("a",{parentName:"p",href:"#transforming-state-with-selectors"},"memoized selector")," that selects a player's health by their ID:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectPlayers = (state: RootState) => state.players;\n\nconst selectPlayerById = (id: number) => {\n    return createSelector([selectPlayers] as const, (players) => {\n        return players.find((player) => player.id === id);\n    });\n};\n\n// highlight-start\nconst selectPlayerHealth = (id: number) => {\n    return createSelector([selectPlayerById(id)] as const, (player) => {\n        return player?.health;\n    });\n};\n// highlight-end\n\nproducer.subscribe(selectPlayerHealth(123), (health, prevHealth) => {\n    // ...\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectPlayers(state)\n    return state.players\nend\n\nlocal function selectPlayerById(id)\n    return Reflex.createSelector({ selectPlayers }, function(players)\n        for _, player in players do\n            if player.id == id then\n                return player\n            end\n        end\n    end)\nend\n\n// highlight-start\nlocal function selectPlayerHealth(id)\n    return Reflex.createSelector({ selectPlayerById(id) }, function(player)\n        return player and player.health\n    end)\nend\n// highlight-end\n\nproducer:subscribe(selectPlayerHealth(123), function(health, prevHealth)\n    -- ...\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"selectPlayerById")," and ",(0,r.kt)("inlineCode",{parentName:"strong"},"selectPlayerHealth")," are ",(0,r.kt)("a",{parentName:"strong",href:"create-selector#selector-factories"},"selector factories"),".")," Factories are useful when you want to create a reusable selector that is memoized for a specific set of inputs. ",(0,r.kt)("a",{parentName:"p",href:"create-selector#passing-input-parameters"},"See more on why this approach helps with performance"),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Now you can subscribe to changes in a specific player's health!")," But creating this subscription for new players and unsubscribing when they are removed can be difficult to set up. This is where the ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," method comes in handy."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," takes a ",(0,r.kt)("strong",{parentName:"p"},"selector"),", an optional ",(0,r.kt)("strong",{parentName:"p"},"discriminator"),", and an ",(0,r.kt)("strong",{parentName:"p"},"Observer"),". The selector returns a list or record of items, in which the Observer is called when a unique item is added. The Observer may return a cleanup function that is automatically called when the item is removed from the list."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The Observer in this code exists throughout the lifetime of each player.")," It can subscribe to changes in the player's health, and run side effects when the player is damaged or dies. When the player no longer alive, they are removed from the list, and the cleanup function is called."),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const discriminator = (player: GamePlayer) => player.id;\n\nproducer.observe(selectAlivePlayers, discriminator, (initialPlayer) => {\n    const { id } = initialPlayer;\n\n    const unsubscribe = producer.subscribe(selectPlayerHealth(id), (health, prevHealth) => {\n        if (health < prevHealth) {\n            playerDamaged();\n        }\n    });\n\n    return () => {\n        unsubscribe();\n        playerDied();\n    };\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function discriminator(player)\n    return player.id\nend\n\nproducer:observe(selectAlivePlayers, discriminator, function(initialPlayer)\n    local id = initialPlayer.id\n\n    local unsubscribe = producer:subscribe(selectPlayerHealth(id), function(health, prevHealth)\n        if health < prevHealth then\n            playerDamaged()\n        end\n    end)\n\n    return function()\n        unsubscribe()\n        playerDied()\n    end\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Remember to pass a discriminator function to ",(0,r.kt)("a",{parentName:"strong",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," if you're observing objects!")," Because of the nature of immutable data, discriminators are necessary to ensure an Observer exists through the entire lifecycle of an object.")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," receives three parameters:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," that returns a list or record of entries."),(0,r.kt)("li",{parentName:"ol"},"An optional ",(0,r.kt)("inlineCode",{parentName:"li"},"discriminator")," function that returns a unique identifier for each entry."),(0,r.kt)("li",{parentName:"ol"},"An ",(0,r.kt)("inlineCode",{parentName:"li"},"observer")," function that is called when an entry is added, and returns a cleanup function that is called when the entry is removed.")),(0,r.kt)("p",null,"The discriminator is optional in the case that your list contains primitives like strings and numbers:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nconst selectPlayerIds = createSelector([selectPlayers] as const, (players) => {\n    return players.map((player) => player.id);\n});\n// highlight-end\n\nproducer.observe(selectPlayerIds, (id: number) => {\n    // mounted\n    return () => {\n        // unmounted\n    };\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"// highlight-start\nlocal selectPlayerIds = Reflex.createSelector({ selectPlayers }, function(players)\n    local ids = {}\n    for index, player in players do\n        ids[index] = player.id\n    end\n    return ids\nend)\n// highlight-end\n\nproducer:observe(selectPlayerIds, function(id: number)\n    -- mounted\n    return function()\n        -- unmounted\n    end\nend)\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"using-middleware"},"Using middleware"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Middleware is a powerful tool for extending the behavior of producers and actions.")," In Reflex, middleware can be used to add logging, cancel actions, add undo/redo functionality, and more."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"middleware#building-middleware"},"See how to create middleware \u2192")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"using-multiple-producers"},"Using multiple producers"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Reflex is best used with a single producer holding the entire state of your app.")," It's also good practice to organize state into different producers, and combine them with ",(0,r.kt)("a",{parentName:"p",href:"combine-producers"},(0,r.kt)("inlineCode",{parentName:"a"},"combineProducers")),"."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"combine-producers"},"See ",(0,r.kt)("inlineCode",{parentName:"a"},"combineProducers")," for more details \u2192")))}k.isMDXComponent=!0}}]);