"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[378],{4829:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var r=n(1966),a=(n(9496),n(9613)),i=n(7934),l=n(4575);const s={description:"Learn how to use the 'observe' method to bind logic to entities"},o="Entities and Observers",d={unversionedId:"guides/entities-and-observers",id:"guides/entities-and-observers",title:"Entities and Observers",description:"Learn how to use the 'observe' method to bind logic to entities",source:"@site/docs/guides/entities-and-observers.md",sourceDirName:"guides",slug:"/guides/entities-and-observers",permalink:"/reflex/docs/guides/entities-and-observers",draft:!1,tags:[],version:"current",frontMatter:{description:"Learn how to use the 'observe' method to bind logic to entities"},sidebar:"learnSidebar",previous:{title:"Using Selectors",permalink:"/reflex/docs/guides/using-selectors"},next:{title:"Advanced Guides",permalink:"/reflex/docs/advanced-guides/"}},u={},c=[{value:"The Observer pattern",id:"the-observer-pattern",level:2},{value:"Understanding Observers",id:"understanding-observers",level:2},{value:"Selecting entities",id:"selecting-entities",level:3},{value:"Tracking additions",id:"tracking-additions",level:3},{value:"Waiting for deletion",id:"waiting-for-deletion",level:3},{value:"Calling the Observer",id:"calling-the-observer",level:3},{value:"Create Observers with <code>observe</code>",id:"create-observers-with-observe",level:2},{value:"Observing individual players",id:"observing-individual-players",level:3},{value:"Summary",id:"summary",level:2}],p={toc:c},y="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(y,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"entities-and-observers"},"Entities and Observers"),(0,a.kt)("p",null,"Often, you'll want to run code over the lifetime of an entity. You can use ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#observeselector-discriminator-observer"},(0,a.kt)("inlineCode",{parentName:"a"},"observe"))," for all kinds of lists and records of entities, from players to in-game matches."),(0,a.kt)("admonition",{title:"we discuss:",type:"note"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"\ud83d\udcda What entities and observers are"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\udd0d How to track an entity manually"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\udd17 How to use ",(0,a.kt)("inlineCode",{parentName:"li"},"observe")," to track entities"))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"the-observer-pattern"},"The Observer pattern"),(0,a.kt)("p",null,"In Reflex, an ",(0,a.kt)("strong",{parentName:"p"},"entity")," is a record of data that represents a player, match, or other object in your game. You can use entities to store data about the object, like its health or position."),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"Observer")," is a function that binds some logic to an entity over its ",(0,a.kt)("em",{parentName:"p"},"lifetime"),". The lifetime of an entity is the time between when it's created and when it's removed from the record."),(0,a.kt)("p",null,"An Observer can be used to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Spawn players when they're added to an ongoing game"),(0,a.kt)("li",{parentName:"ul"},"Apply temporary status effects to players"),(0,a.kt)("li",{parentName:"ul"},"Clean up connections when players are eliminated or disconnect")),(0,a.kt)("p",null,"And much more! ",(0,a.kt)("a",{parentName:"p",href:"https://sleitnick.github.io/RbxObservers/docs/observer-pattern"},"Read more about the Observer pattern \u2192")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"understanding-observers"},"Understanding Observers"),(0,a.kt)("p",null,"On ",(0,a.kt)("a",{parentName:"p",href:"subscribing-to-state"},"Subscribing to State"),", you learned how to use ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,a.kt)("inlineCode",{parentName:"a"},"subscribe")),", ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#onceselector-predicate-listener"},(0,a.kt)("inlineCode",{parentName:"a"},"once")),", and ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#waitselector-predicate"},(0,a.kt)("inlineCode",{parentName:"a"},"wait"))," to run side effects for a player's health bar. But the examples only covered running side effects on ",(0,a.kt)("em",{parentName:"p"},"one")," player. How can you bind this extra logic for the lifetime of ",(0,a.kt)("em",{parentName:"p"},"every")," player?"),(0,a.kt)("p",null,"We can use ",(0,a.kt)("inlineCode",{parentName:"p"},"observe")," to do this, but to understand how to use ",(0,a.kt)("inlineCode",{parentName:"p"},"observe"),", let's first look at how you might write your own Observer."),(0,a.kt)("p",null,"A general implementation of Observers requires a few things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"A record of entities to track"),(0,a.kt)("li",{parentName:"ol"},"Call the Observer when an entity is ",(0,a.kt)("strong",{parentName:"li"},"added"),", and clean up when it's ",(0,a.kt)("strong",{parentName:"li"},"removed")),(0,a.kt)("li",{parentName:"ol"},"A way to identify the entity to track its whole lifetime")),(0,a.kt)("h3",{id:"selecting-entities"},"Selecting entities"),(0,a.kt)("p",null,"To track entities, you need a record of them. In the ",(0,a.kt)("a",{parentName:"p",href:"subscribing-to-state#player-list"},"Player list")," example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"players")," slice stores a map of players by their ID. You can write a selector that returns this record:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { RootState } from "./producer";\n\nexport const selectPlayersById = (state: RootState) => {\n    return state.players.entities;\n};\n'))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local producer = require(script.Parent.producer)\n\nlocal function selectPlayersById(state: producer.RootState)\n    return state.players.entities\nend\n")))),(0,a.kt)("h3",{id:"tracking-additions"},"Tracking additions"),(0,a.kt)("p",null,"To track when an entity is added to the record, you can use the current and previous states passed to ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,a.kt)("inlineCode",{parentName:"a"},"subscribe")),". When a player is added to the record, the previous state will not have the player, but the current state will. You can use this to filter out new players:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function entityAdded(entity: PlayerEntity) {\n    // Player was added\n}\n\nproducer.subscribe(selectPlayersById, (current, previous) => {\n    for (const [id, player] of pairs(current)) {\n        if (previous[id] === undefined) {\n            // highlight-next-line\n            entityAdded(player);\n        }\n    }\n});\n"))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local function entityAdded(entity: players.PlayerEntity)\n    -- Player was added\nend\n\nproducer:subscribe(selectPlayersByid, function(current, previous)\n    for id, player in current do\n        if previous[id] == nil then\n            // highlight-next-line\n            entityAdded(player)\n        end\n    end\nend)\n")))),(0,a.kt)("h3",{id:"waiting-for-deletion"},"Waiting for deletion"),(0,a.kt)("p",null,"To track when an entity is removed from the record, you can use ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#onceselector-predicate-listener"},(0,a.kt)("inlineCode",{parentName:"a"},"once"))," to create a listener that runs when the entity is not in the new state:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function entityAdded(entity: PlayerEntity) {\n    const doesNotHaveEntity = (entities: PlayerEntityRecord) => {\n        return entities[entity.id] === undefined;\n    };\n\n    // highlight-start\n    producer.once(selectPlayersById, doesNotHaveEntity, () => {\n        // Player was removed\n    });\n    // highlight-end\n}\n"))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local function entityAdded(entity: players.PlayerEntity)\n    local function doesNotHaveEntity(entities: players.PlayerEntityRecord)\n        return entities[entity.id] == nil\n    end\n\n    // highlight-start\n    producer:once(selectPlayersById, doesNotHaveEntity, function()\n        -- Player was removed\n    end)\n    // highlight-end\nend\n")))),(0,a.kt)("h3",{id:"calling-the-observer"},"Calling the Observer"),(0,a.kt)("p",null,"Now that you have a way to track entities, you can connect an Observer to the entity's lifetime:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Observer"',title:'"Observer"'},"function playerObserver(player: PlayerEntity) {\n    // Player was added\n\n    return () => {\n        // Player was removed\n    };\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Observer handler"',title:'"Observer','handler"':!0},"function entityAdded(entity: PlayerEntity) {\n    const doesNotHaveEntity = (entities: PlayerEntityRecord) => {\n        return entities[entity.id] === undefined;\n    };\n\n    // highlight-next-line\n    const cleanup = playerObserver(entity);\n\n    producer.once(selectPlayersById, doesNotHaveEntity, () => {\n        // highlight-next-line\n        cleanup();\n    });\n}\n\nproducer.subscribe(selectPlayersById, (current, previous) => {\n    for (const [id, player] of pairs(current)) {\n        if (previous[id] === undefined) {\n            entityAdded(player);\n        }\n    }\n});\n"))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Observer"',title:'"Observer"'},"local function playerObserver(player: players.PlayerEntity)\n    -- Player was added\n\n    return function()\n        -- Player was removed\n    end\nend\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="Observer handler"',title:'"Observer','handler"':!0},"local function entityAdded(entity: players.PlayerEntity)\n    local function doesNotHaveEntity(entities: players.PlayerEntityRecord)\n        return entities[entity.id] == nil\n    end\n\n    // highlight-next-line\n    local cleanup = playerObserver(entity)\n\n    producer:once(selectPlayersById, doesNotHaveEntity, function()\n        // highlight-next-line\n        cleanup()\n    end)\nend\n\nproducer:subscribe(selectPlayersById, function(current, previous)\n    for id, player in current do\n        if previous[id] == nil then\n            entityAdded(player)\n        end\n    end\nend)\n")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"We've brought the Observer pattern into Reflex!")," You can run side effects in the ",(0,a.kt)("inlineCode",{parentName:"p"},"playerObserver")," function, and clean them up when the Observer is removed."),(0,a.kt)("p",null,"While this works, it's a lot of code to write for something that should be simple. This is where ",(0,a.kt)("inlineCode",{parentName:"p"},"observe")," comes in."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"create-observers-with-observe"},"Create Observers with ",(0,a.kt)("inlineCode",{parentName:"h2"},"observe")),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#observeselector-discriminator-observer"},(0,a.kt)("inlineCode",{parentName:"a"},"observe"))," method is a shorthand for creating Observers. It takes a ",(0,a.kt)("em",{parentName:"p"},"selector"),", a ",(0,a.kt)("em",{parentName:"p"},"discriminator"),", and an ",(0,a.kt)("em",{parentName:"p"},"Observer")," function."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("strong",{parentName:"li"},"selector")," is used to select a record of entities to track, and it can return an array or a dictionary. We will use the ",(0,a.kt)("a",{parentName:"li",href:"#selecting-entities"},(0,a.kt)("inlineCode",{parentName:"a"},"selectPlayersById"))," selector from earlier."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("strong",{parentName:"li"},"discriminator")," is a function that takes the current state and returns a value that uniquely identifies the entity. We will use the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," property of the entity."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("strong",{parentName:"li"},"Observer")," function runs when an entity is added, and returns an optional cleanup function that runs when the entity is removed.")),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const getPlayerId = (player: PlayerEntity) => {\n    return player.id;\n};\n\nproducer.observe(selectPlayersById, getPlayerId, (player) => {\n    // Player was added\n\n    return () => {\n        // Player was removed\n    };\n});\n"))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local function getPlayerId(player: players.PlayerEntity)\n    return player.id\nend\n\nproducer:observe(selectPlayersById, getPlayerId, function(player)\n    -- Player was added\n\n    return function()\n        -- Player was removed\n    end\nend)\n")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"This is essentially the same as our custom Observers, but with ",(0,a.kt)("em",{parentName:"strong"},"much")," less code!")," The ",(0,a.kt)("inlineCode",{parentName:"p"},"observe")," method will automatically track when the entity is added and removed, and run the Observer function accordingly."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"If the record is already populated with entities,")," the Observer function will be initialized for each entity in the record when you call ",(0,a.kt)("inlineCode",{parentName:"p"},"observe"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"The discriminator function is optional.")," If you don't provide one, the entity itself will be used as the discriminator. This is only recommended if the entity is a primitive value, like a string or number.")))),(0,a.kt)("h3",{id:"observing-individual-players"},"Observing individual players"),(0,a.kt)("p",null,"On ",(0,a.kt)("a",{parentName:"p",href:"subscribing-to-state"},"Subscribing to State"),", we left off at playing a sound when one player gets damaged. We made a ",(0,a.kt)("a",{parentName:"p",href:"using-selectors#passing-arguments-to-selectors"},"selector factory")," to select the health of a player by ID, wrote a ",(0,a.kt)("inlineCode",{parentName:"p"},"didDecrease")," predicate to check if the health decreased, and subscribed to decreases in health:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const selectPlayerHealthById = (id: string) => {\n    return (state: RootState) => {\n        return state.players.entities[id].health;\n    };\n};\n\nconst didDecrease = (current: number, previous: number) => {\n    return current < previous;\n};\n\nconst selectHealth = selectPlayerHealthById("Player1");\n\n// highlight-start\nproducer.subscribe(selectHealth, didDecrease, () => {\n    // Play sound\n});\n// highlight-end\n'))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectPlayerHealthById(id: string)\n    return function(state: RootState)\n        return state.players.entities[id].health\n    end\nend\n\nlocal function didDecrease(current: number, previous: number)\n    return current < previous\nend\n\nlocal selectHealth = selectPlayerHealthById("Player1")\n\n// highlight-start\nproducer:subscribe(selectHealth, didDecrease, function()\n    -- Play sound\nend)\n// highlight-end\n')))),(0,a.kt)("p",null,"But now that we can observe the lifetime players, we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"observe")," to play a sound when any player gets damaged:"),(0,a.kt)(i.Z,{groupId:"languages",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"producer.observe(selectPlayersById, getPlayerId, (player) => {\n    const selectHealth = selectPlayerHealthById(player.id);\n\n    // highlight-start\n    return producer.subscribe(selectHealth, didDecrease, () => {\n        // Play sound\n    });\n    // highlight-end\n});\n"))),(0,a.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"producer:observe(selectPlayersById, getPlayerId, function(player)\n    local selectHealth = selectPlayerHealthById(player.id)\n\n    // highlight-start\n    return producer:subscribe(selectHealth, didDecrease, function()\n        -- Play sound\n    end)\n    // highlight-end\nend)\n")))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-handler"},(0,a.kt)("inlineCode",{parentName:"a"},"subscribe"))," method returns a cleanup function that disconnects the listener. We can return this function as our Observer's cleanup function.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"You're now ready to use Reflex in your games!")," The guides from here on out will focus on more advanced topics, but you can always refer back to the earlier guides if you need a refresher."),(0,a.kt)("p",null,"Let's recap what we've learned about Observers:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Entities")," are unique objects that can be added and removed from the state."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Observers")," are functions that run over the lifetime of an entity."),(0,a.kt)("li",{parentName:"ul"},"To create an observer, call ",(0,a.kt)("a",{parentName:"li",href:"../reference/reflex/producer#observeselector-discriminator-observer"},(0,a.kt)("inlineCode",{parentName:"a"},"observe"))," with a selector, a discriminator, and an Observer function.")))}h.isMDXComponent=!0}}]);