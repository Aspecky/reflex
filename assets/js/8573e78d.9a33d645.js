"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[470],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,h=p["".concat(i,".").concat(d)]||p[d]||m[d]||l;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=d;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[p]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<l;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4575:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(9496),r=n(5924);const l={tabItem:"tabItem_rlDe"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,s),hidden:n},t)}},7934:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(1966),r=n(9496),l=n(5924),s=n(6888),o=n(3442),i=n(4475),c=n(8423),u=n(1010);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=m(e),[s,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[i,c]=h({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),k=(()=>{const e=i??p;return d({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{k&&o(k)}),[k]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),f(e)}),[c,f,l]),tabValues:l}}var k=n(6648);const b={tabList:"tabList_t2F_",tabItem:"tabItem_TXTv"};function g(e){let{className:t,block:n,selectedValue:o,selectValue:i,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,s.o5)(),m=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==o&&(p(t),i(a))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:d,onClick:m},s,{className:(0,l.Z)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":o===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=f(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",b.tabList)},r.createElement(g,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function N(e){const t=(0,k.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},6859:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var a=n(1966),r=(n(9496),n(9613)),l=n(7934),s=n(4575);const o={sidebar_position:4},i="createSelector",c={unversionedId:"reference/reflex/apis/create-selector",id:"reference/reflex/apis/create-selector",title:"createSelector",description:"createSelector lets you skip re-computing a value if the inputs/dependencies haven't changed.",source:"@site/docs/reference/reflex/apis/create-selector.md",sourceDirName:"reference/reflex/apis",slug:"/reference/reflex/apis/create-selector",permalink:"/reflex/docs/reference/reflex/apis/create-selector",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"referenceSidebar",previous:{title:"combineProducers",permalink:"/reflex/docs/reference/reflex/apis/combine-producers"},next:{title:"Client APIs",permalink:"/reflex/docs/reference/reflex/client-apis/"}},u={},p=[{value:"Reference",id:"reference",level:2},{value:"<code>createSelector(dependencies, combiner)</code>",id:"createselectordependencies-combiner",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Usage",id:"usage",level:2},{value:"Transforming state",id:"transforming-state",level:3},{value:"Passing arguments to selectors",id:"passing-arguments-to-selectors",level:3},{value:"Selector factories",id:"selector-factories",level:4},{value:"Troubleshooting",id:"troubleshooting",level:2}],m={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"createselector"},"createSelector"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createSelector")," lets you skip re-computing a value if the inputs/dependencies haven't changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selector = createSelector(dependencies, combiner);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#reference"},"Reference"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector(dependencies, combiner)"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#usage"},"Usage"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#transforming-state"},"Transforming state")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#troubleshooting"},"Troubleshooting"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("h3",{id:"createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"h3"},"createSelector(dependencies, combiner)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createSelector")," returns a ",(0,r.kt)("em",{parentName:"p"},"memoized")," selector. This memoized selector will not call the combiner unless the arguments or the results of ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," have changed. Calling this selector will pass the input arguments to each dependency, and then pass the results of those dependencies to the ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," function is called with the results of the dependencies as arguments, in the same order as the dependencies passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"createSelector"),". The result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," is the final value that the selector will cache and return."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectArray = (state: State) => state.array;\nconst selectMap = (state: State) => state.map;\n\nconst selectValues = createSelector([selectArray, selectMap] as const, (array, map) => {\n    return [...array, ...Object.values(map)];\n});\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectArray(state: State)\n    return state.array\nend\n\nlocal function selectMap(state: State)\n    return state.map\nend\n\nlocal selectValues = createSelector({ selectArray, selectMap }, function(array, map)\n    local values = table.clone(array)\n    for _, value in map do\n        table.insert(values, value)\n    end\n    return values\nend)\n")))),(0,r.kt)("p",null,"Both the ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," are memoized. This means that the dependencies are not called unless the arguments to the selector have changed, and the combiner is not called unless the dependencies return new values."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#usage"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," - An array of selectors, the results of which will be passed to the combiner."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"combiner")," - A function that takes the results of the dependencies and returns a value.")),(0,r.kt)("h4",{id:"returns"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createSelector")," returns a memoized selector. It behaves as a normal selector, but the result is cached and only re-computed if the arguments or dependencies change."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Your functions should be ",(0,r.kt)("em",{parentName:"strong"},"idempotent"),";")," they should always return the same result for the same inputs. Otherwise, the selector may not work as expected.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Dependencies are compared by reference (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),").")," Even if a function returns an object that's shallowly equal to the previous result, it will still be seen as an update, and the selector will still re-compute.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"If you're writing a selector returns a new object or array")," (i.e. filtering, sorting, etc.), you should ",(0,r.kt)("strong",{parentName:"p"},"always")," use ",(0,r.kt)("inlineCode",{parentName:"p"},"createSelector"),". Otherwise, the selector will return a new object/array every time it's called, and listeners will run excessively. ",(0,r.kt)("a",{parentName:"p",href:"producer#subscribeselector-listener"},"See the ",(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")," function for other caveats."))))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"transforming-state"},"Transforming state"),(0,r.kt)("p",null,"Often, you'll want to sort a list of items, filter out items that don't match a certain criteria, or perform some other transformation on your state. But trying to include these transformations in your state can quickly become difficult to keep up-to-date. ",(0,r.kt)("strong",{parentName:"p"},"Selectors are a great way to derive new values from state!")," With selectors, you can create a new object/array and apply transformations as needed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"But one small mistake can worsen performance or cause unexpected behavior.")," Let's say you have a list of items in your cart, and you want to filter out items that are out of stock. Your producer might look something like this:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface CartState {\n    readonly items: readonly CartItem[];\n}\n\ninterface CartItem {\n    readonly name: string;\n    readonly price: number;\n    readonly stock: number;\n}\n\nconst initialState: CartState = {\n    items: [],\n};\n\nconst producer = createProducer(initialState, {\n    addItem: (state, item: CartItem) => ({\n        ...state,\n        items: [...state.items, item],\n    }),\n});\n"))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type CartState = {\n    items: { CartItem },\n}\n\ntype CartItem = {\n    name: string,\n    price: number,\n    stock: number,\n}\n\nlocal initialState: CartState = {\n    items = {},\n}\n\nlocal producer = createProducer(initialState, {\n    addItem = function(state, item: CartItem)\n        local nextState = table.clone(state)\n        local nextItems = table.clone(state.items)\n\n        table.insert(nextItems, item)\n        nextState.items = nextItems\n\n        return nextState\n    end,\n})\n")))),(0,r.kt)("p",null,"You have a shopping cart that contains a list of items, each with a ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"price"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"stock")," property. How would you ",(0,r.kt)("a",{parentName:"p",href:"producer#running-side-effects"},"subscribe")," to state and filter out items that are in stock?"),(0,r.kt)("p",null,"Your first instinct might be to write a simple function that filters items with a ",(0,r.kt)("inlineCode",{parentName:"p"},"stock")," above zero:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectInStock = (state: CartState) => {\n    // error-next-line\n    return state.items.filter((item) => item.stock > 0);\n};\n\nproducer.subscribe(selectInStock, (stock) => {\n    print("Items available:", stock);\n});\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectInStock(state: CartState)\n    // error-next-line\n    local stock = {}\n    for _, item in state.items do\n        if item.stock == 0 then\n            table.insert(stock, item)\n        end\n    end\n    // error-next-line\n    return stock\nend\n\nproducer:subscribe(selectInStock, function(stock)\n    print("Items available:", stock)\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This works, but it's not very efficient.")," The listener will run every time the state updates, even if the items themselves haven't changed!"),(0,r.kt)("admonition",{title:"why?",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"By ",(0,r.kt)("a",{parentName:"p",href:"producer#running-side-effects"},"subscribing to state")," with a selector, you essentially tell Reflex to run your selector ",(0,r.kt)("strong",{parentName:"p"},"every time the state changes.")," This is to compare the result with the previous value to detect a change, which is fine for simple selectors, but it can be inefficient if your selector returns new tables and functions, or is expensive to compute."),(0,r.kt)("p",{parentName:"admonition"},"In this case, every time the selector is called, it creates an ",(0,r.kt)("strong",{parentName:"p"},"entirely new list")," of in-stock items. This is bad because ",(0,r.kt)("a",{parentName:"p",href:"producer#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," compares the new value to the previous value by reference (",(0,r.kt)("inlineCode",{parentName:"p"},"==="),"), and since the selector only returns new arrays, Reflex will consider every unrelated state change to be an update. ",(0,r.kt)("strong",{parentName:"p"},"Your listener will be called excessively, even if the items haven't changed!"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Memoization"))," is a technique that allows you to cache the result of a function, and only re-compute it if the arguments change. ",(0,r.kt)("a",{parentName:"p",href:"#createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," offers a simple way to memoize selectors and avoid unnecessary re-computations, and is useful for writing efficient selectors that only run when needed."),(0,r.kt)("p",null,"We can wrap the selector in ",(0,r.kt)("a",{parentName:"p",href:"#createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")),", and specify ",(0,r.kt)("inlineCode",{parentName:"p"},"state.items")," as a dependency. With this change, the selector will only be called when ",(0,r.kt)("inlineCode",{parentName:"p"},"state.items")," updates:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectItems = (state: CartState) => state.items;\n\n// highlight-start\nconst selectInStock = createSelector([selectItems] as const, (items) => {\n    return items.filter((item) => item.stock > 0);\n});\n// highlight-end\n\nproducer.subscribe(selectInStock, (stock) => {\n    print("Items available:", stock);\n});\n'))),(0,r.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectItems(state: CartState)\n    return state.items\nend\n\n// highlight-start\nlocal selectInStock = createSelector({ selectItems }, function(items)\n    local stock = {}\n    for _, item in items do\n        if item.stock == 0 then\n            table.insert(stock, item)\n        end\n    end\n    return stock\nend)\n// highlight-end\n\nproducer:subscribe(selectInStock, function(stock)\n    print("Items available:", stock)\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("inlineCode",{parentName:"strong"},"selectInStock")," function is now ",(0,r.kt)("em",{parentName:"strong"},"memoized"),".")," In other words, it will only return a new list of items in-stock if ",(0,r.kt)("inlineCode",{parentName:"p"},"state.items")," changed. This is much safer and more efficient than the previous example."),(0,r.kt)("p",null,"You'd pass two arguments to ",(0,r.kt)("a",{parentName:"p",href:"#createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"An array of dependencies, which are selectors that the memoized selector depends on."),(0,r.kt)("li",{parentName:"ol"},'A "combiner" function that transforms the dependencies into a new value.')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#createselectordependencies-combiner"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," then returns a new, memoized selector. Both the dependencies and the combiner function are memoized, so the selector will only re-compute if the selector arguments ",(0,r.kt)("em",{parentName:"p"},"and")," the combiner dependencies change. There are three steps the selector takes to determine the return value:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Make sure the arguments have changed since the last call."),(0,r.kt)("li",{parentName:"ol"},"Call each dependency with the arguments and check if any of them changed."),(0,r.kt)("li",{parentName:"ol"},"Call the combiner function with the new results of each dependency.")),(0,r.kt)("p",null,"If all of the steps above pass, the selector will return the new value. Otherwise, it will return the previous value and skip the combiner function. The process is very fast, and helps keep your selectors efficient."),(0,r.kt)("p",null,"For a more in-depth explanation of selectors, check out the ",(0,r.kt)("a",{parentName:"p",href:"https://redux.js.org/usage/deriving-data-selectors"},"official Redux documentation.")," Most of the concepts apply to Reflex as well."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"passing-arguments-to-selectors"},"Passing arguments to selectors"),(0,r.kt)("p",null,"A common use case for selectors is to find a specific item in a list, but passing external arguments to a selector is unintuitive."),(0,r.kt)("p",null,"We'll go over two main ways to pass arguments to a selector:"),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#selector-factories"},(0,r.kt)("strong",{parentName:"a"},"Selector factories:"))," Pass arguments to a selector factory, which returns a new selector.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#currying"},(0,r.kt)("strong",{parentName:"a"},"Currying:"))," A dependency selector defines new arguments that come after the state argument."))),(0,r.kt)("h4",{id:"selector-factories"},"Selector factories"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"troubleshooting"},"Troubleshooting"))}h.isMDXComponent=!0}}]);