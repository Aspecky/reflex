"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[461],{2664:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>p});var a=o(1966),n=(o(9496),o(9613)),r=o(7934),s=o(4575);const d={sidebar_position:1,description:"Learn how to write a producer in Reflex."},i="Your First Producer",l={unversionedId:"guides/your-first-producer",id:"guides/your-first-producer",title:"Your First Producer",description:"Learn how to write a producer in Reflex.",source:"@site/docs/guides/your-first-producer.md",sourceDirName:"guides",slug:"/guides/your-first-producer",permalink:"/reflex/docs/guides/your-first-producer",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Learn how to write a producer in Reflex."},sidebar:"docsSidebar",previous:{title:"Guides",permalink:"/reflex/docs/category/guides"},next:{title:"Organizing Producers",permalink:"/reflex/docs/guides/organizing-producers"}},u={},p=[{value:"What is a producer?",id:"what-is-a-producer",level:2},{value:"Creating a producer",id:"creating-a-producer",level:2},{value:"State",id:"state",level:3},{value:"Actions",id:"actions",level:3},{value:"Using a producer",id:"using-a-producer",level:2},{value:"Organizing producers",id:"organizing-producers",level:3},{value:"Summary",id:"summary",level:2}],c={toc:p},m="wrapper";function h(e){let{components:t,...o}=e;return(0,n.kt)(m,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"your-first-producer"},"Your First Producer"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Producers")," are the building blocks of Reflex. They are the state containers that hold your state and actions, and you can use them to read and subscribe to your state."),(0,n.kt)("admonition",{title:"we discuss:",type:"note"},(0,n.kt)("ul",{parentName:"admonition"},(0,n.kt)("li",{parentName:"ul"},"\ud83d\udd0d What a producer is"),(0,n.kt)("li",{parentName:"ul"},"\u2728 How to create a producer"),(0,n.kt)("li",{parentName:"ul"},"\ud83d\udee0\ufe0f How to use your producer"))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"what-is-a-producer"},"What is a producer?"),(0,n.kt)("p",null,"A ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/producer"},"producer")," is a state container that you can use to dispatch actions or observe state changes. They're designed to be used as a single source of truth for your state, and provide an all-in-one interface for managing your game's state."),(0,n.kt)("p",null,"Unlike ",(0,n.kt)("a",{parentName:"p",href:"https://roblox.github.io/"},"Rodux"),", which delegates state management to reducers, Reflex skips this step and allows actions to set your state. Reflex aims to be quick to set up and easy to use, and producers are the core of that philosophy."),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"creating-a-producer"},"Creating a producer"),(0,n.kt)("p",null,"Traditionally, state management libraries like ",(0,n.kt)("a",{parentName:"p",href:"https://roblox.github.io/rodux"},"Rodux")," require you to create a reducer function that takes in an action and returns a new state. Reflex takes a different approach and allows the actions themselves to update the state. Here's what a producer might look like:"),(0,n.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.ts" showLineNumbers',title:'"todos.ts"',showLineNumbers:!0},'import { createProducer } from "@rbxts/reflex";\n\nexport interface TodosState {\n    readonly todos: readonly string[];\n}\n\nconst initialState: TodosState = {\n    todos: [],\n};\n\nexport const todos = createProducer(initialState, {\n    addTodo: (state, todo: string) => ({\n        ...state,\n        todos: [...state.todos, todo],\n    }),\n\n    removeTodo: (state, todo: string) => ({\n        ...state,\n        todos: state.todos.filter((t) => t !== todo),\n    }),\n});\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="todos.lua" showLineNumbers',title:'"todos.lua"',showLineNumbers:!0},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nexport type TodosState = {\n    todos: { string },\n}\n\nexport type TodosActions = {\n    addTodo: (todo: string) -> (),\n    removeTodo: (todo: string) -> (),\n}\n\nexport type TodosProducer = Reflex.Producer<TodosState, TodosActions>\n\nlocal initialState: TodosState = {\n    todos = {},\n}\n\nlocal todos = Reflex.createProducer(initialState, {\n    addTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.insert(nextTodos, todo)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n\n    removeTodo = function(state: TodosState, todo: string): TodosState\n        local nextState = table.clone(state)\n        local nextTodos = table.clone(state.todos)\n\n        table.remove(nextTodos, table.find(nextTodos, todo) or -1)\n        nextState.todos = nextTodos\n\n        return nextState\n    end,\n}) :: TodosProducer\n\nreturn todos\n")))),(0,n.kt)("p",null,"A producer consists of:"),(0,n.kt)("h3",{id:"state"},"State"),(0,n.kt)("p",null,"The ",(0,n.kt)("strong",{parentName:"p"},"state")," is the data that your producer holds. It's the source of truth for your game or app, and can only be modified by your actions. In the example above, the state is an object with a ",(0,n.kt)("inlineCode",{parentName:"p"},"todos")," property, which is an array of strings."),(0,n.kt)("p",null,"You've probably noticed that the state is marked as ",(0,n.kt)("inlineCode",{parentName:"p"},"readonly"),". This is because Reflex is an ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Immutable_object"},"immutable")," state container. You can't write to the state directly, and instead must return a new state from your actions."),(0,n.kt)("h3",{id:"actions"},"Actions"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Actions")," are functions that modify your state. They should be ",(0,n.kt)("em",{parentName:"p"},"idempotent"),", meaning that they should always return the same result when given the same arguments. In the example above, ",(0,n.kt)("inlineCode",{parentName:"p"},"addTodo")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"removeTodo")," are actions that modify the ",(0,n.kt)("inlineCode",{parentName:"p"},"todos")," property of the state."),(0,n.kt)("p",null,"To add a todo to the list, you would simply run ",(0,n.kt)("inlineCode",{parentName:"p"},"todos.addTodo(name)"),". Note that these are not methods, so you shouldn't use the ",(0,n.kt)("inlineCode",{parentName:"p"},":")," operator to call them in Luau."),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"using-a-producer"},"Using a producer"),(0,n.kt)("p",null,"Now that you've created a producer, you're free to read and modify its state. For example, you can print the list of todos whenever it changes:"),(0,n.kt)(r.Z,{groupId:"languages",mdxType:"Tabs"},(0,n.kt)(s.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},'import { TodosState, todos } from "./todos";\n\nconst selectTodos = (state: TodosState) => state.todos;\n\ntodos.subscribe(selectTodos, (todos) => {\n    print(`TODO: ${todos.join(", ")}`);\n});\n\ntodos.addTodo("Buy milk");\ntodos.addTodo("Buy eggs");\n'))),(0,n.kt)(s.Z,{value:"Luau",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua",metastring:"showLineNumbers",showLineNumbers:!0},'local todos = require(script.Parent.todos)\n\nlocal function selectTodos(state: todos.TodosState)\n    return state.todos\nend\n\ntodos:subscribe(selectTodos, function(todos)\n    print("TODO: " .. table.concat(todos, ", "))\nend)\n\ntodos.addTodo("Buy milk")\ntodos.addTodo("Buy eggs")\n')))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},"--\x3e TODO: Buy milk, Buy eggs\n")),(0,n.kt)("p",null,"This example ",(0,n.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},"subscribes")," to changes in ",(0,n.kt)("inlineCode",{parentName:"p"},"state.todos")," and prints the list of todos whenever it changes. After adding ",(0,n.kt)("inlineCode",{parentName:"p"},"Buy milk")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"Buy eggs")," to the list, it prints the updated list."),(0,n.kt)("h3",{id:"organizing-producers"},"Organizing producers"),(0,n.kt)("p",null,"Reflex is designed to have one root producer be the ",(0,n.kt)("strong",{parentName:"p"},"single source of truth")," for your state. This producer can be composed of smaller slices that handle different parts of your state."),(0,n.kt)("p",null,"For example, you could have a ",(0,n.kt)("inlineCode",{parentName:"p"},"calendar")," producer that stores important dates, and a ",(0,n.kt)("inlineCode",{parentName:"p"},"todos")," producer that handles the list of todos. You will learn more about this in the ",(0,n.kt)("a",{parentName:"p",href:"organizing-producers"},"next guide"),"."),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"summary"},"Summary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Producers")," are state containers that hold your state and actions."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Actions")," are functions that modify your state."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"State")," is the immutable data that your producer holds."),(0,n.kt)("li",{parentName:"ul"},"You can ",(0,n.kt)("strong",{parentName:"li"},"subscribe")," to changes in your state using ",(0,n.kt)("inlineCode",{parentName:"li"},"subscribe"),"."),(0,n.kt)("li",{parentName:"ul"},"The producer exposes your actions as callbacks, which you can call to change the state.")))}h.isMDXComponent=!0}}]);