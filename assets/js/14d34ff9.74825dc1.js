"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[992],{6998:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var a=n(1966),r=(n(9496),n(9613)),s=n(7934),l=n(4575);const o={sidebar_position:3,description:"Learn how to dispatch actions and run side effects in Reflex."},i="Using Selectors",c={unversionedId:"guides/using-selectors",id:"guides/using-selectors",title:"Using Selectors",description:"Learn how to dispatch actions and run side effects in Reflex.",source:"@site/docs/guides/using-selectors.md",sourceDirName:"guides",slug:"/guides/using-selectors",permalink:"/reflex/docs/guides/using-selectors",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,description:"Learn how to dispatch actions and run side effects in Reflex."},sidebar:"docsSidebar",previous:{title:"Organizing Producers",permalink:"/reflex/docs/guides/organizing-producers"},next:{title:"Subscribing to State",permalink:"/reflex/docs/guides/subscribing-to-state"}},d={},u=[{value:"Immutable state and actions",id:"immutable-state-and-actions",level:2},{value:"Selecting state",id:"selecting-state",level:2},{value:"Transforming state",id:"transforming-state",level:3},{value:"Passing arguments to selectors",id:"passing-arguments-to-selectors",level:3},{value:"Stateful selectors",id:"stateful-selectors",level:3},{value:"Summary",id:"summary",level:2}],p={toc:u},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-selectors"},"Using Selectors"),(0,r.kt)("p",null,"Games often have complex interactions between different parts of the state. Producers let you subscribe to state changes with ",(0,r.kt)("em",{parentName:"p"},"selectors"),"."),(0,r.kt)("admonition",{title:"we discuss:",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"\u26a1\ufe0f How to write actions"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd2d How to run side effects"),(0,r.kt)("li",{parentName:"ul"},"\ud83c\udf70 How to write selectors"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd10 When to memoize selectors"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd25 How to write more powerful selectors"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"immutable-state-and-actions"},"Immutable state and actions"),(0,r.kt)("p",null,"You learned that producers are ",(0,r.kt)("strong",{parentName:"p"},"immutable")," state containers, so state changes are made by dispatching ",(0,r.kt)("em",{parentName:"p"},"actions")," that output a new state object. When you want an action to update the state, you apply the changes to new objects instead of mutating the existing state:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const calendarSlice = createProducer(initialState, {\n    addEvent: (state, event: CalendarEvent) => ({\n        ...state,\n        events: [...state.events, event],\n    }),\n\n    removeEvent: (state, name: string) => ({\n        ...state,\n        events: state.events.filter((e) => e.name !== name),\n    }),\n});\n"))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local calendarSlice = Reflex.createProducer(initialState, {\n    addEvent = function(state: CalendarState, event: CalendarEvent): CalendarState\n        local nextState = table.clone(state)\n        local nextEvents = table.clone(state.events)\n\n        table.insert(nextEvents, event)\n        nextState.events = nextEvents\n\n        return nextState\n    end,\n\n    removeEvent = function(state: CalendarState, name: string): CalendarState\n        local nextState = table.clone(state)\n        local nextEvents: { CalendarEvent } = {}\n\n        for _, event in state.events do\n            if event.name ~= name then\n                table.insert(nextEvents, event)\n            end\n        end\n\n        nextState.events = nextEvents\n\n        return nextState\n    end,\n})\n")))),(0,r.kt)("p",null,"Actions can then be dispatched through the root producer to update the state:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectEvents = (state: RootState) => state.calendar.events;\n\nproducer.subscribe(selectEvents, (events) => {\n    print("EVENTS:");\n    for (const event of events) {\n        print(`- ${event.name} (${event.date})`);\n    }\n});\n\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\nproducer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\nproducer:subscribe(selectEvents, function(events)\n    print("EVENTS:")\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\nproducer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# EVENTS:\n# - Birthday (2004-12-27)\n# - Learn Reflex (2023-03-17)\n")),(0,r.kt)("p",null,"We've been using selectors like ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEvents")," and the ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," method, but we haven't talked about how they work yet. Let's take a look at how selectors work in Reflex."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"selecting-state"},"Selecting state"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Selectors")," are functions that take the root state and return a subset of it. They can be as simple as indexing a property, or as complex as filtering and transforming data. Selectors are used to subscribe to state changes, and to read state in side effects."),(0,r.kt)("p",null,"In the previous examples, the ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEvents")," selector is simple and returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," property of the calendar slice. But what if you want to get the events sorted by date? You could move that logic to a reusable selector:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectEventsByTime = (state: RootState) => {\n    // error-next-line\n    return [...state.calendar.events].sort((a, b) => {\n        const timeA = DateTime.fromIsoDate(a.date);\n        const timeB = DateTime.fromIsoDate(b.date);\n        return timeA.UnixTimestamp < timeB.UnixTimestamp;\n    });\n};\n\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\nproducer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\n\nfor (const date of producer.getState(selectEventsByTime)) {\n    print(`${date.date} - ${date.name}`);\n}\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectEventsByTime(state: producer.RootState)\n    // error-next-line\n    local events = table.clone(state.calendar.events)\n\n    table.sort(events, function(a, b)\n        local timeA = DateTime.fromIsoDate(a.date)\n        local timeB = DateTime.fromIsoDate(b.date)\n        return timeA.UnixTimestamp < timeB.UnixTimestamp\n    end)\n\n    return events\nend\n\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\nproducer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\n\nfor _, date in producer:getState(selectEventsByTime) do\n    print(date.date .. " - " .. date.name)\nend\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# 2004-12-27 - Birthday\n# 2023-03-17 - Learn Reflex\n")),(0,r.kt)("p",null,"This works, and you now have a selector that returns the events sorted by date!"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"But there's a catch"),": every time you call ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime"),", it will create a new array. This can cause problems when you try to ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/producer#subscribeselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," to the selector:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'producer.subscribe(selectEventsByTime, (events) => {\n    print("EVENTS:");\n    for (const event of events) {\n        print(`- ${event.name} (${event.date})`);\n    }\n});\n\n// highlight-next-line\nproducer.addTodo("Unrelated todo");\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer:subscribe(selectEventsByTime, function(events)\n    print("EVENTS:")\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n\n// highlight-next-line\nproducer.addTodo("Unrelated todo")\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# error-next-line\n# EVENTS:\n")),(0,r.kt)("p",null,"Oh no! We added a ",(0,r.kt)("strong",{parentName:"p"},"todo item"),", which is in a different slice of the state, but the listener still ran and tried to print the events. Normally, this listener ",(0,r.kt)("strong",{parentName:"p"},"shouldn't run")," because the events did not change. This is because of how Reflex detects state updates."),(0,r.kt)("h3",{id:"transforming-state"},"Transforming state"),(0,r.kt)("p",null,"When you create a subscription, Reflex will call the selector function and store the result. Then, when the state changes, Reflex will call the selector again and compare the result to the previous result. If the results are not ",(0,r.kt)("strong",{parentName:"p"},"equal (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),")"),", the listener will be called with the new result."),(0,r.kt)("p",null,"Right now, our ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime")," creates a new array ",(0,r.kt)("strong",{parentName:"p"},"every time")," it is called. This means that the result will never be equal to the previous result, and the listener will always be called. But if we also can't sort the original array because ",(0,r.kt)("a",{parentName:"p",href:"#immutable-state-and-actions"},"state is immutable"),", what can we do to transform state?"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Memoization")," is a technique that can be used to ",(0,r.kt)("strong",{parentName:"p"},"cache")," the result of a function. If the function is called with the same arguments, the cached result can be returned instead of recalculating it. Reflex exports the ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," function to create memoized selectors:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector } from "@rbxts/reflex";\n\nconst selectEvents = (state: RootState) => state.calendar.events;\n\n// highlight-next-line\nconst selectEventsByTime = createSelector([selectEvents] as const, (events) => {\n    return [...events].sort((a, b) => {\n        const timeA = DateTime.fromIsoDate(a.date);\n        const timeB = DateTime.fromIsoDate(b.date);\n        return timeA.UnixTimestamp < timeB.UnixTimestamp;\n    });\n});\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\n// highlight-next-line\nlocal selectEventsByTime = Reflex.createSelector({ selectEvents }, function(events)\n    local events = table.clone(events)\n\n    table.sort(events, function(a, b)\n        local timeA = DateTime.fromIsoDate(a.date)\n        local timeB = DateTime.fromIsoDate(b.date)\n        return timeA.UnixTimestamp < timeB.UnixTimestamp\n    end)\n\n    return events\nend)\n")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"You'd call ",(0,r.kt)("a",{parentName:"strong",href:"../reference/reflex/create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," with two arguments:")),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"dependencies"),", an array of selectors that the ",(0,r.kt)("inlineCode",{parentName:"li"},"combiner")," depends on"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"combiner"),", a function that takes the results of the ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," and returns a new state")),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"combiner")," won't run unless the dependencies or arguments change, so it's safer to do expensive operations and return new objects in it."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector"},"Read more about ",(0,r.kt)("inlineCode",{parentName:"a"},"createSelector")," \u2192"))),(0,r.kt)("p",null,"With our new ",(0,r.kt)("strong",{parentName:"p"},"memoized")," selector, the listener will only be called when the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," dependency changes:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'producer.subscribe(selectEventsByTime, (events) => {\n    print("EVENTS:");\n    for (const event of events) {\n        print(`- ${event.name} (${event.date})`);\n    }\n});\n\nproducer.addTodo("Unrelated todo");\n\ntask.wait(1);\n\nproducer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer:subscribe(selectEventsByTime, function(events)\n    print("EVENTS:")\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n\nproducer.addTodo("Unrelated todo")\n\ntask.wait(1)\n\nproducer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# EVENTS:\n# - Birthday (2004-12-27)\n# - Learn Reflex (2023-03-17)\n")),(0,r.kt)("p",null,"Now, we can subscribe to an automatically-sorted list of events efficiently!"),(0,r.kt)("p",null,"Using selectors this way allows you to ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/create-selector#transforming-state"},"derive new information")," from state while keeping your producers and slices simple. This is a common pattern in Rodux applications, and it's a good idea to use it in Reflex too."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Memoizing selectors is a good idea, but it's not always necessary.")," You should prefer to memoize selectors that are expensive or return new objects; indexing a table or returning a primitive value is cheap and doesn't need to be memoized.")),(0,r.kt)("h3",{id:"passing-arguments-to-selectors"},"Passing arguments to selectors"),(0,r.kt)("p",null,"Often, you may want to pass arguments to a selector. For example, you may want to select a specific calendar event by its name. There are two main ways to do this:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"../reference/reflex/create-selector#selector-factories"},"Selector factories")," that return a selector function for a given set of arguments"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"../reference/reflex/create-selector#dependency-currying"},"Currying")," arguments by adding them to the ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," array")),(0,r.kt)("p",null,"There are pros and cons to each approach, but we'll only cover selector factories because they're more ergonomic."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("strong",{parentName:"p"},"selector factory")," that returns a selector function for a given event name:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createSelector } from "@rbxts/reflex";\n\nconst selectEvents = (state: RootState) => state.calendar.events;\n\n// highlight-next-line\nconst selectEventByName = (name: string) => {\n    return createSelector([selectEvents] as const, (events) => {\n        return events.find((event) => event.name === name);\n    });\n};\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Reflex = require(ReplicatedStorage.Packages.Reflex)\n\nlocal function selectEvents(state: producer.RootState)\n    return state.calendar.events\nend\n\n// highlight-next-line\nlocal function selectEventByName(name: string)\n    return Reflex.createSelector({ selectEvents }, function(events)\n        for _, event in events do\n            if event.name == name then\n                return event\n            end\n        end\n    end)\nend\n")))),(0,r.kt)("p",null,"With our new selector factory, we can create a selector for a specific event:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// highlight-next-line\nconst selectBirthday = selectEventByName("Birthday");\n\nproducer.subscribe(selectBirthday, (event) => {\n    print(`Birthday is on ${event.date}`);\n});\n\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'// highlight-next-line\nlocal selectBirthday = selectEventByName("Birthday")\n\nproducer:subscribe(selectBirthday, function(event)\n    print("Birthday is on " .. event.date)\nend)\n\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Birthday is on 2004-12-27\n")),(0,r.kt)("p",null,"Selector factories are a nice and simple way to create selectors specialized for a given set of arguments. This pattern can be used to create selectors for a specific user, apply a sort filter, or any other transformation that depends on external arguments."),(0,r.kt)("h3",{id:"stateful-selectors"},"Stateful selectors"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#passing-arguments-to-selectors"},"Selector factories")," are great for creating selectors that depend on external arguments, but they have the added benefit that the selectors you create are ",(0,r.kt)("strong",{parentName:"p"},"unique"),". You can add variables and logic that are only accessible to a specific selector, which can be used for a variety of cases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Memoizing results with a custom equality function, like shallow equality"),(0,r.kt)("li",{parentName:"ul"},"Storing a cache of previous results"),(0,r.kt)("li",{parentName:"ul"},"Tracking the addition and removal of entities")),(0,r.kt)("p",null,"Let's create a selector that further memoizes the combiner of ",(0,r.kt)("inlineCode",{parentName:"p"},"selectEventsByTime")," with a custom equality function:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectEventsByTime = () => {\n    let lastEvents: CalendarEvent[] = [];\n    let lastResult: CalendarEvent[] = [];\n\n    return createSelector([selectEvents] as const, (events) => {\n        // highlight-start\n        if (shallowEqual(events, lastEvents)) {\n            return lastResult;\n        }\n        // highlight-end\n\n        lastEvents = events;\n\n        lastResult = [...events].sort((a, b) => {\n            const timeA = DateTime.fromIsoDate(a.date);\n            const timeB = DateTime.fromIsoDate(b.date);\n            return timeA.UnixTimestamp < timeB.UnixTimestamp;\n        });\n\n        return lastResult;\n    });\n};\n"))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectEventsByTime()\n    local lastEvents: { calendar.CalendarEvent } = {}\n    local lastResult: { calendar.CalendarEvent } = {}\n\n    return Reflex.createSelector({ selectEvents }, function(events)\n        // highlight-start\n        if shallowEqual(events, lastEvents) then\n            return lastResult\n        end\n        // highlight-end\n\n        lastEvents = events\n        lastResult = table.create(events)\n\n        table.sort(lastResult, function(a, b)\n            local timeA = DateTime.fromIsoDate(a.date)\n            local timeB = DateTime.fromIsoDate(b.date)\n            return timeA.UnixTimestamp < timeB.UnixTimestamp\n        end)\n\n        return lastResult\n    end)\nend\n")))),(0,r.kt)("p",null,"Now, using this selector will only call the listener when the events change ",(0,r.kt)("strong",{parentName:"p"},"and")," the events are not shallowly equal to the previous events:"),(0,r.kt)(s.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'producer.addEvent({ name: "Learn Reflex", date: "2023-03-17" });\nproducer.addEvent({ name: "Birthday", date: "2004-12-27" });\n\nproducer.subscribe(selectEventsByTime(), (events) => {\n    print("EVENTS:");\n    for (const event of events) {\n        print(`- ${event.name} (${event.date})`);\n    }\n});\n\n// highlight-next-line\nproducer.removeEvent("This event doesn\'t exist");\n'))),(0,r.kt)(l.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'producer.addEvent({ name = "Learn Reflex", date = "2023-03-17" })\nproducer.addEvent({ name = "Birthday", date = "2004-12-27" })\n\nproducer:subscribe(selectEventsByTime(), function(events)\n    print("EVENTS:")\n    for _, event in events do\n        print("- " .. event.name .. " (" .. event.date .. ")")\n    end\nend)\n\n// highlight-next-line\nproducer.removeEvent("This event doesn\'t exist")\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# \u2705 No output\n")),(0,r.kt)("p",null,"Normally, the listener would be called when removing an event that doesn't exist. This makes sense if you check the ",(0,r.kt)("a",{parentName:"p",href:"#immutable-state-and-actions"},"implementation of ",(0,r.kt)("inlineCode",{parentName:"a"},"removeEvent")),", as the ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," property is updated to a new array regardless of whether an event was removed."),(0,r.kt)("p",null,"Because we're using a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"shallowEquality")," function to filter out these false triggers, the listener is not called. You can also write your own utility functions to apply custom logic like this to your selectors."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can update the state of a producer by calling ",(0,r.kt)("strong",{parentName:"li"},"actions"),"."),(0,r.kt)("li",{parentName:"ul"},"You can ",(0,r.kt)("strong",{parentName:"li"},"subscribe")," to a producer to listen for state changes."),(0,r.kt)("li",{parentName:"ul"},"You can create ",(0,r.kt)("strong",{parentName:"li"},"selectors")," to select a subset of the state and listen for changes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Memoizing")," selectors can improve performance and reduce redundant updates."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Selector factories")," can be used to create selectors that depend on external arguments."),(0,r.kt)("li",{parentName:"ul"},"Selector factories can hold their own ",(0,r.kt)("strong",{parentName:"li"},"state"),".")))}h.isMDXComponent=!0}}]);