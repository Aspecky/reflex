"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[665],{9613:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(9496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(a),m=r,h=c["".concat(o,".").concat(m)]||c[m]||d[m]||l;return a?n.createElement(h,i(i({ref:t},u),{},{components:a})):n.createElement(h,i({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4575:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(9496),r=a(5924);const l={tabItem:"tabItem_rlDe"};function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,i),hidden:a},t)}},7934:(e,t,a)=>{a.d(t,{Z:()=>N});var n=a(1966),r=a(9496),l=a(5924),i=a(6888),s=a(3442),o=a(4475),p=a(8423),u=a(1010);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,s.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,o._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function k(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=d(e),[i,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[o,p]=h({queryString:a,groupId:n}),[c,k]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,u.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),f=(()=>{const e=o??c;return m({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),p(e),k(e)}),[p,k,l]),tabValues:l}}var f=a(6648);const b={tabList:"tabList_t2F_",tabItem:"tabItem_TXTv"};function g(e){let{className:t,block:a,selectedValue:s,selectValue:o,tabValues:p}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.o5)(),d=e=>{const t=e.currentTarget,a=u.indexOf(t),n=p[a].value;n!==s&&(c(t),o(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":a},t)},p.map((e=>{let{value:t,label:a,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:d},i,{className:(0,l.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":s===t})}),a??t)})))}function y(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function v(e){const t=k(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",b.tabList)},r.createElement(g,(0,n.Z)({},e,t)),r.createElement(y,(0,n.Z)({},e,t)))}function N(e){const t=(0,f.Z)();return r.createElement(v,(0,n.Z)({key:String(t)},e))}},1606:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var n=a(1966),r=(a(9496),a(9613)),l=a(7934),i=a(4575);const s={sidebar_position:2},o="Producer",p={unversionedId:"reference/reflex/apis/producer",id:"reference/reflex/apis/producer",title:"Producer",description:"A producer is a state container with built-in functions to update state and run side effects. To create one, use createProducer.",source:"@site/docs/reference/reflex/apis/producer.md",sourceDirName:"reference/reflex/apis",slug:"/reference/reflex/apis/producer",permalink:"/reflex/docs/reference/reflex/apis/producer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"referenceSidebar",previous:{title:"createProducer",permalink:"/reflex/docs/reference/reflex/apis/create-producer"},next:{title:"combineProducers",permalink:"/reflex/docs/reference/reflex/apis/combine-producers"}},u={},c=[{value:"Reference",id:"reference",level:2},{value:"<code>action</code> functions",id:"action-functions",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"<code>getState(selector?)</code>",id:"getstateselector",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"<code>subscribe(selector?, listener)</code>",id:"subscribeselector-listener",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"<code>once(selector, predicate?, listener)</code>",id:"onceselector-predicate-listener",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"<code>wait(selector, predicate?)</code>",id:"waitselector-predicate",level:3},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-4",level:4},{value:"<code>observe(selector, discriminator?, observer)</code>",id:"observeselector-discriminator-observer",level:3},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-5",level:4},{value:"<code>flush()</code>",id:"flush",level:3},{value:"<code>applyMiddleware(...middlewares)</code>",id:"applymiddlewaremiddlewares",level:3},{value:"Parameters",id:"parameters-6",level:4},{value:"Returns",id:"returns-6",level:4},{value:"Usage",id:"usage",level:2},{value:"Running side effects",id:"running-side-effects",level:3},{value:"Waiting for state changes",id:"waiting-for-state-changes",level:3},{value:"Deriving new data from state",id:"deriving-new-data-from-state",level:3},{value:"Observing additions and removals",id:"observing-additions-and-removals",level:3},{value:"Using middleware",id:"using-middleware",level:3},{value:"Using multiple producers",id:"using-multiple-producers",level:3}],d={toc:c},m="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"producer"},"Producer"),(0,r.kt)("p",null,"A producer is a state container with built-in functions to update state and run side effects. To create one, use ",(0,r.kt)("a",{parentName:"p",href:"create-producer"},(0,r.kt)("inlineCode",{parentName:"a"},"createProducer")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(initialState, actions);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#reference"},"Reference"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#action-functions"},(0,r.kt)("inlineCode",{parentName:"a"},"action")," functions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#getstateselector"},(0,r.kt)("inlineCode",{parentName:"a"},"getState(selector?)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe(selector?, listener)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once(selector, predicate?, listener)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"a"},"wait(selector, predicate?)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe(selector, discriminator?, observer)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#flush"},(0,r.kt)("inlineCode",{parentName:"a"},"flush()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#applymiddlewaremiddlewares"},(0,r.kt)("inlineCode",{parentName:"a"},"applyMiddleware(...middlewares)"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#usage"},"Usage"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#running-side-effects"},"Running side effects")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#waiting-for-state-changes"},"Waiting for state changes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#deriving-new-data-from-state"},"Deriving new data from state")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#observing-additions-and-removals"},"Observing additions and removals")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#using-middleware"},"Using middleware")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#using-multiple-producers"},"Using multiple producers"))))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("h3",{id:"action-functions"},(0,r.kt)("inlineCode",{parentName:"h3"},"action")," functions"),(0,r.kt)("p",null,"Actions are functions that update the producer's state. They are created by passing an object of action functions to ",(0,r.kt)("a",{parentName:"p",href:"create-producer"},(0,r.kt)("inlineCode",{parentName:"a"},"createProducer")),"."),(0,r.kt)("p",null,"You can dispatch an action by calling it on the producer:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const producer = createProducer(0, {\n    increment: (state, value: number) => state + value,\n});\n\n// highlight-next-line\nproducer.increment(1); // 1\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local producer = Reflex.createProducer(0, {\n    increment = function(state, value: number): number\n        return state + value\n    end,\n})\n\n// highlight-next-line\nproducer.increment(1) --\x3e 1\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"create-producer#updating-state"},"See how to create actions here.")),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"...args")," - The parameters to pass to the action function.")),(0,r.kt)("h4",{id:"returns"},"Returns"),(0,r.kt)("p",null,"Dispatching returns the new state of the producer."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getstateselector"},(0,r.kt)("inlineCode",{parentName:"h3"},"getState(selector?)")),(0,r.kt)("p",null,"Producers allow you to access the current state by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"getState"),". You can optionally pass a selector function to ",(0,r.kt)("inlineCode",{parentName:"p"},"getState")," to select a specific part of the state."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.getState(); // { count: 0 }\nproducer.getState((state) => state.count); // 0\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer:getState() --\x3e { count = 0 }\nproducer:getState(function(state)\n    return state.count\nend) --\x3e 0\n")))),(0,r.kt)("h4",{id:"parameters-1"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," - A function that selects a part of the state. If not provided, the entire state is returned.")),(0,r.kt)("h4",{id:"returns-1"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getState")," returns the current state of the producer, or the result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"selector")," if one is provided."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"h3"},"subscribe(selector?, listener)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," method lets you listen for changes to the producer's state. Generally, you should pass a selector function to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," to only listen for changes to a subset of the state."),(0,r.kt)("p",null,"To unsubscribe from a listener, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),"."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectCount = (state: State) => state.count;\n\nconst unsubscribe = producer.subscribe(selectCount, (count, prevCount) => {\n    print(count, prevCount);\n});\n\nproducer.increment(1); // 1, 0\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectCount(state)\n    return state.count\nend\n\nlocal unsubscribe = producer:subscribe(selectCount, function(count, prevCount)\n    print(count, prevCount)\nend)\n\nproducer.increment(1) --\x3e 1, 0\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#running-side-effects"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-2"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state. If not provided, the entire state is passed to the listener.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"listener")," - A function that is called when the state changes. The function receives the state as its first argument, and the previous state as its second argument."))),(0,r.kt)("h4",{id:"returns-2"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," returns a function that can be called to unsubscribe the listener."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you pass a selector to ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),", the listener will only be called once the selector returns a new value. Changes are compared ",(0,r.kt)("strong",{parentName:"p"},"by reference (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),")"),", so if your selector creates a new object, remember to ",(0,r.kt)("a",{parentName:"p",href:"create-selector"},"memoize it with ",(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"State updates within a ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," event should only be done in response to a selected state or under certain conditions. Otherwise, you may end up in an infinite loop.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Listeners are called synchronously ",(0,r.kt)("strong",{parentName:"p"},"on the frame after an action is dispatched"),". This means that if you dispatch multiple actions in the same frame, listeners will only be called once with the final state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Similar to Redux, if you subscribe, unsubscribe, or change state while a listener is being called, the changes will not affect the current dispatch. However, they will affect the next dispatch.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"h3"},"once(selector, predicate?, listener)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"once")," lets you listen for a single change to the producer's state. It works similarly to ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),", but the listener is automatically unsubscribed after the first call. If the predicate is provided, the listener will only be called if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,"To unsubscribe from a listener, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"once"),"."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCounter = (state: State) => state.count;\n\nconst isGreaterThanOne = (count: number) => count > 1;\n\nproducer.once(selectCounter, isGreaterThanOne, (count, prevCount) => {\n    print(count, "is greater than 1");\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCounter(state)\n    return state.count\nend\n\nlocal function isGreaterThanOne(count)\n    return count > 1\nend\n\nproducer:once(selectCounter, isGreaterThanOne, function(count, prevCount)\n    print(count, "is greater than 1")\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-3"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," - A function that determines whether the listener should be called. If not provided, the listener will be called once the selected state changes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"listener")," - A function that is called when the state changes. The function receives the new state as its first argument, and the state from the time of subscription as its second argument."))),(0,r.kt)("h4",{id:"returns-3"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"once")," returns a function that can be called to unsubscribe the listener."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"once")," has the ",(0,r.kt)("a",{parentName:"p",href:"#caveats"},"same caveats")," as ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at the time of subscription, the listener ",(0,r.kt)("strong",{parentName:"p"},"will not")," be called immediately. It will only be called once the selected state changes, and only if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at that time. This behavior is analogous to ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise.fromEvent")," and how it waits for the ",(0,r.kt)("em",{parentName:"p"},"next")," event.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"h3"},"wait(selector, predicate?)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wait")," returns a promise that resolves once the selected state changes. If the predicate is provided, the promise will only resolve if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,"To unsubscribe from a listener, cancel the promise returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"wait"),"."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCounter = (state: State) => state.count;\n\nconst isGreaterThanOne = (count: number) => count > 1;\n\nproducer.wait(selectCounter, isGreaterThanOne).then((count) => {\n    print(count, "is greater than 1");\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCounter(state)\n    return state.count\nend\n\nlocal function isGreaterThanOne(count)\n    return count > 1\nend\n\nproducer:wait(selectCounter, isGreaterThanOne):andThen(function(count)\n    print(count, "is greater than 1")\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-4"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," - A function that determines whether the promise should resolve. If not provided, the promise will resolve once the selected state changes."))),(0,r.kt)("h4",{id:"returns-4"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"wait")," returns a promise that resolves once the selected state changes ",(0,r.kt)("em",{parentName:"p"},"and")," the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"wait")," has the ",(0,r.kt)("a",{parentName:"p",href:"#caveats"},"same caveats")," as ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe")),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at the time ",(0,r.kt)("inlineCode",{parentName:"p"},"wait")," is called, the Promise ",(0,r.kt)("strong",{parentName:"p"},"will not")," resolve immediately. It will only be resolve once the selected state changes, and only if the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," at that time. This behavior is analogous to ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise.fromEvent")," and how it waits for the ",(0,r.kt)("em",{parentName:"p"},"next")," event.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"h3"},"observe(selector, discriminator?, observer)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"observe")," lets you track the addition and removal of a ",(0,r.kt)("strong",{parentName:"p"},"unique item")," in the producer's state. The selector may return an array or a record of items. When an item is added, the Observer is called with the item, and cleaned up when the item is removed."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"discriminator")," is used to differentiate between items. If the discriminator is not provided, the item is tracked by its reference in the record. If the discriminator is provided, the item is tracked by the result of the discriminator."),(0,r.kt)("p",null,"To unsubscribe from an Observer, call the function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"observe"),"."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectTodos = (state: State) => state.todos;\n\nconst identifyTodo = (todo: Todo) => todo.id;\n\nproducer.observe(selectTodos, identifyTodo, (todo) => {\n    print(todo, "was added");\n\n    return () => {\n        print(todo, "was removed");\n    };\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectTodos(state)\n    return state.todos\nend\n\nlocal function identifyTodo(todo)\n    return todo.id\nend\n\nproducer:observe(selectTodos, identifyTodo, function(todo)\n    print(todo, "was added")\n\n    return function()\n        print(todo, "was removed")\n    end\nend)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#observing-additions-and-removals"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-5"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," - A function that selects a part of the state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"optional")," ",(0,r.kt)("inlineCode",{parentName:"p"},"discriminator")," - A function that returns a unique identifier for an item. If not provided, the item is tracked by its reference in the record.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"observer")," - Called when an item is added to the record. It returns an optional cleanup function that is called when the item is removed from the state."))),(0,r.kt)("h4",{id:"returns-5"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"observe")," returns a function that can be called to unsubscribe from the state and clean up all Observers."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Passing a discriminator is highly recommended when tracking unique objects.")," This is because immutable objects are compared by reference. If you pass a record of objects without a discriminator, the Observer will be called every time an object is updated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The discriminator must return a unique value for each item.")," If two items have the same discriminator, Observers will track the first to be added or removed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The Observer is called immediately for each item in the initial state.")," This means that if the state is already populated with items, the Observer will be called for each item.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The first argument of the Observer is the item that was added.")," It acts as an initial state and ",(0,r.kt)("strong",{parentName:"p"},"does not update")," when the item is updated.")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"flush"},(0,r.kt)("inlineCode",{parentName:"h3"},"flush()")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"flush")," method is used to immediately run a scheduled update. This is useful for forcing an update to run synchronously, but should generally be avoided."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.flush();\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer:flush()\n")))),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"flush")," should not be called during a state update. Doing so might cause unexpected behavior."))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"applymiddlewaremiddlewares"},(0,r.kt)("inlineCode",{parentName:"h3"},"applyMiddleware(...middlewares)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," method is used to apply middleware to the producer. Middleware can be used to enhance producers, dispatch actions, or perform side effects."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const loggerMiddleware: ProducerMiddleware = (producer) => {\n    print("initial state:", producer.getState());\n\n    producer.subscribe((state) => {\n        print("next state:", state);\n    });\n\n    return (dispatch, name) => {\n        return (...args) => {\n            print(`dispatching ${name}:`, ...args);\n            return dispatch(...args);\n        };\n    };\n};\n\nproducer.applyMiddleware(loggerMiddleware);\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local loggerMiddleware: Reflex.Middleware = function(producer)\n    print("initial state:", producer:getState())\n\n    producer:subscribe(function(state)\n        print("next state:", state)\n    end)\n\n    return function(dispatch, name)\n        return function(...)\n            print("dispatching", name, ...)\n            return dispatch(...)\n        end\n    end\nend\n\nproducer:applyMiddleware(loggerMiddleware)\n')))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#using-middleware"},"See more examples below.")),(0,r.kt)("h4",{id:"parameters-6"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"...middlewares")," - A list of middleware functions. The middleware functions are called in the order they are provided.")),(0,r.kt)("h4",{id:"returns-6"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," returns the original producer."),(0,r.kt)("admonition",{title:"Caveats",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Middleware functions have ",(0,r.kt)("strong",{parentName:"p"},"three layers")," of abstraction: the producer, the dispatch function, and individual dispatches. The producer is the ",(0,r.kt)("strong",{parentName:"p"},"highest level of abstraction")," and is called once when applying the middleware. The dispatch function is the ",(0,r.kt)("strong",{parentName:"p"},"middle layer of abstraction")," and called with the dispatch functions in the producer. The individual dispatches are the ",(0,r.kt)("strong",{parentName:"p"},"lowest level of abstraction")," and run before each dispatch.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Middleware functions are called in the order they are provided.")," This means that middleware functions that depend on other middleware functions should be provided after their dependencies.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The return value matters!")," Middleware functions can intercept dispatches and make them return a value other than the new state. If a middleware function returns a value, the next middleware function will receive that value, and eventually will be returned by the dispatch function.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"running-side-effects"},"Running side effects"),(0,r.kt)("p",null,"Games often have a lot of state that changes over time. For example, a producer might contain a player's health, money, and inventory. You will sometimes need to perform side effects for certain state updates. Let's first look at how to subscribe to state changes, and then we'll cover which cases you should use it for."),(0,r.kt)("p",null,"To subscribe to state changes, use the ",(0,r.kt)("a",{parentName:"p",href:"#subscribeselector-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"subscribe"))," method:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const selectCount = (state: State) => state.count;\n\nproducer.subscribe(selectCount, (count) => {\n    print("count changed:", count);\n});\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function selectCount(state)\n    return state.count\nend\n\nproducer:subscribe(selectCount, function(count, prevCount)\n    print("count changed:", count)\nend)\n')))),(0,r.kt)("p",null,"You pass two parameters to the ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," method:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," that returns the part of the state you want to subscribe to."),(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"listener")," that is called when the selected part of the state changes.")),(0,r.kt)("p",null,"Once you have subscribed to state changes, you can perform side effects in the listener function. The listener will be called once the selector returns a new value after a state update."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Say you have a game where the player's health is stored in the state:")),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface RootState {\n    readonly health: number;\n}\n\nconst initialState: RootState = {\n    health: 100,\n};\n\nconst producer = createProducer(initialState, {\n    takeDamage: (state, health: number) => ({\n        ...state,\n        health: state.health - health,\n    }),\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"type RootState = {\n    health: number,\n}\n\ntype RootDispatchers = {\n    takeDamage: (health: number) -> void,\n}\n\nlocal initialState = {\n    health = 100,\n}\n\nlocal producer = createProducer(initialState, {\n    takeDamage = function(state, health)\n        local nextState = table.clone(state)\n        nextState.health -= health\n        return nextState\n    end,\n}) :: Reflex.Producer<RootState, RootDispatchers>\n")))),(0,r.kt)("p",null,"Your producer has an action to deal damage to the player, but it's not good practice to run side effects in actions. So, how can you run a side effect when damage is dealt?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"You can do this by subscribing to a selector that returns the player's health:")),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectHealth = (state: RootState) => state.health;\n\nproducer.subscribe(selectHealth, (health, prevHealth) => {\n    if (health < prevHealth) {\n        playDamageSound();\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectHealth(state)\n    return state.health\nend\n\nproducer:subscribe(selectHealth, function(health, prevHealth)\n    if health < prevHealth then\n        playDamageSound()\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This code calls the ",(0,r.kt)("inlineCode",{parentName:"strong"},"playDamageSound")," function whenever the player's health decreases.")," The listener is called with the new health and the previous health. If the new health is less than the previous health, the listener plays a sound."),(0,r.kt)("p",null,"But what if you want to wait for some specific state change to occur? ",(0,r.kt)("a",{parentName:"p",href:"#waiting-for-state-changes"},"Producers provide methods for that, too!")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"waiting-for-state-changes"},"Waiting for state changes"),(0,r.kt)("p",null,"Sometimes, you want to wait for a specific state change before performing a side effect."),(0,r.kt)("p",null,"For example, say your state contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"jumping")," boolean that is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," when the player holds down the jump button. You want it to run a ",(0,r.kt)("inlineCode",{parentName:"p"},"jump()")," function in a loop, and disconnect it when it stops. One way to do this is with ",(0,r.kt)("a",{parentName:"p",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once")),"."),(0,r.kt)("p",null,"This code calls the function while the ",(0,r.kt)("inlineCode",{parentName:"p"},"jumping")," state is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", and then stops once the ",(0,r.kt)("inlineCode",{parentName:"p"},"jumping")," state becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectJumping = (state: RootState) => state.jumping;\n\nconst isFalse = (value: boolean) => value === false;\n\nproducer.subscribe(selectJumping, (jumping) => {\n    if (jumping) {\n        const heartbeat = RunService.Heartbeat.Connect(jump);\n\n        producer.once(selectJumping, isFalse, (jumping) => {\n            heartbeat.Disconnect();\n        });\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectJumping(state)\n    return state.jumping\nend\n\nlocal function isFalse(value)\n    return value == false\nend\n\nproducer:subscribe(selectJumping, function(jumping)\n    if jumping then\n        local heartbeat = RunService.Heartbeat:Connect(jump)\n\n        producer:once(selectJumping, isFalse, function(jumping)\n            heartbeat:Disconnect()\n        end)\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("a",{parentName:"strong",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once"))," method receives three parameters:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," that returns the part of the state you want to subscribe to"),(0,r.kt)("li",{parentName:"ol"},"An optional ",(0,r.kt)("inlineCode",{parentName:"li"},"predicate")," that returns ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," when the state change you are waiting for has occurred"),(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"listener")," that is called when the state has changed")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," parameter is optional. If you pass a predicate, the listener will only be called when the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),". Otherwise, the listener will be called when the selector returns a new value."),(0,r.kt)("p",null,"Producers also provide ",(0,r.kt)("a",{parentName:"p",href:"#waitselector-predicate"},(0,r.kt)("inlineCode",{parentName:"a"},"wait")),", a shorthand for ",(0,r.kt)("a",{parentName:"p",href:"#onceselector-predicate-listener"},(0,r.kt)("inlineCode",{parentName:"a"},"once"))," that returns a promise:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectJumping = (state: RootState) => state.jumping;\n\nconst isFalse = (value: boolean) => value === false;\n\nasync function startJumping() {\n    const heartbeat = RunService.Heartbeat.Connect(jump);\n\n    return producer.wait(selectJumping, isFalse).finally(() => {\n        heartbeat.Disconnect();\n    });\n}\n\nproducer.subscribe(selectJumping, (jumping) => {\n    if (jumping) {\n        startJumping();\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectJumping(state)\n    return state.jumping\nend\n\nlocal function isFalse(value)\n    return value == false\nend\n\nlocal function startJumping()\n    local heartbeat = RunService.Heartbeat:Connect(jump)\n\n    return producer:wait(selectJumping, isFalse):finally(function()\n        heartbeat:Disconnect()\n    end)\nend\n\nproducer:subscribe(selectJumping, function(jumping)\n    if jumping then\n        startJumping()\n    end\nend)\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"deriving-new-data-from-state"},"Deriving new data from state"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A good rule of thumb is to keep your state as simple as possible.")," This includes avoiding redundant data that can be derived from other parts of the state. However, that might make it harder to perform side effects on your existing state. How can you ",(0,r.kt)("strong",{parentName:"p"},"derive new data")," from the state without changing it?"),(0,r.kt)("p",null,"Say your game's state contains a list of players, and each player has a ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," property. If you want to retrieve a list of players that are alive, you can create a ",(0,r.kt)("strong",{parentName:"p"},"selector")," that creates a new list of players from the existing state:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectPlayers = (state: RootState) => state.players;\n\nconst selectAlivePlayers = createSelector([selectPlayers] as const, (players) => {\n    return players.filter((player) => player.health > 0);\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectPlayers(state)\n    return state.players\nend\n\nlocal selectAlivePlayers = Reflex.createSelector({ selectPlayers }, function(players)\n    local alivePlayers = {}\n\n    for _, player in players do\n        if player.health > 0 then\n            table.insert(alivePlayers, player)\n        end\n    end\n\n    return alivePlayers\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Using ",(0,r.kt)("a",{parentName:"strong",href:"create-selector"},(0,r.kt)("inlineCode",{parentName:"a"},"createSelector"))," for deriving new objects is good practice.")," It allows you to ",(0,r.kt)("strong",{parentName:"p"},"memoize")," a selector and cache its results. Note that this is best used when the selector ",(0,r.kt)("strong",{parentName:"p"},"returns a new object")," (mapping, filtering, etc.) or ",(0,r.kt)("strong",{parentName:"p"},"performs a heavy computation"),". A simple table index does not need to be memoized."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"This is because state changes are determined by reference equality (",(0,r.kt)("inlineCode",{parentName:"strong"},"==="),").")," If Reflex calls your selector and it always returns a new table, Reflex will think that the state has changed ",(0,r.kt)("strong",{parentName:"p"},"every time")," the selector is called. This can lead to performance issues down the line.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"With this selector, you can subscribe to changes in the list of alive players.")," Your original state hasn't changed, but you can now filter out the players that are alive and perform side effects based on that."),(0,r.kt)("p",null,"For example, you can run some code whenever a player is filtered from the list of alive players:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.subscribe(selectAlivePlayers, (alivePlayers, prevAlivePlayers) => {\n    for (const player of prevAlivePlayers) {\n        const stillAlive = alivePlayers.some((p) => p.id === player.id);\n\n        if (!stillAlive) {\n            playerDied(player);\n        }\n    }\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function hasPlayer(players, id)\n    for _, player in players do\n        if player.id == id then\n            return true\n        end\n    end\n\n    return false\nend\n\nproducer:subscribe(selectAlivePlayers, function(alivePlayers, prevAlivePlayers)\n    for _, player in prevAlivePlayers do\n        if not hasPlayer(alivePlayers, player.id) then\n            playerDied(player)\n        end\n    end\nend)\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"But finding differences between lists can quickly get cumbersome.")," What if you want to track the health of a specific player? Or what if you want to clean up some state when a player dies?"),(0,r.kt)("p",null,"This is where the ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," method comes in handy. ",(0,r.kt)("a",{parentName:"p",href:"#observing-additions-and-removals"},"See how to use it in the next section.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"observing-additions-and-removals"},"Observing additions and removals"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Game state often contains many lists and records of data.")," You will likely need to run code when a new item is added to a record, or clean something up when the item is removed. We'll explore Observers, their use cases, and using ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Reflex brings the ",(0,r.kt)("a",{parentName:"strong",href:"https://sleitnick.github.io/RbxObservers/docs/observer-pattern"},"Observer pattern")," to immutable state management.")," Some good use cases for ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Managing the lifecycle of a match in a multiplayer game"),(0,r.kt)("li",{parentName:"ul"},"Spawning players and cleaning up when they die or leave the game"),(0,r.kt)("li",{parentName:"ul"},"Applying temporary status effects to players")),(0,r.kt)("p",null,"Let's say your state has a list of players, and each player has a ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," property. You want to play a sound whenever a player is damaged or dies. To help track individual players, you should first create a ",(0,r.kt)("a",{parentName:"p",href:"#deriving-new-data-from-state"},"memoized selector")," that selects a player's health by their ID:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const selectPlayers = (state: RootState) => state.players;\n\nconst selectPlayerById = (id: number) => {\n    return createSelector([selectPlayers] as const, (players) => {\n        return players.find((player) => player.id === id);\n    });\n};\n\n// highlight-start\nconst selectPlayerHealth = (id: number) => {\n    return createSelector([selectPlayerById(id)] as const, (player) => {\n        return player?.health;\n    });\n};\n// highlight-end\n\nproducer.subscribe(selectPlayerHealth(123), (health, prevHealth) => {\n    // ...\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function selectPlayers(state)\n    return state.players\nend\n\nlocal function selectPlayerById(id)\n    return Reflex.createSelector({ selectPlayers }, function(players)\n        for _, player in players do\n            if player.id == id then\n                return player\n            end\n        end\n    end)\nend\n\n// highlight-start\nlocal function selectPlayerHealth(id)\n    return Reflex.createSelector({ selectPlayerById(id) }, function(player)\n        return player and player.health\n    end)\nend\n// highlight-end\n\nproducer:subscribe(selectPlayerHealth(123), function(health, prevHealth)\n    -- ...\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"selectPlayerById")," and ",(0,r.kt)("inlineCode",{parentName:"strong"},"selectPlayerHealth")," are selector creators.")," Creators are useful when you want to create a reusable selector that is memoized for a specific set of inputs. ",(0,r.kt)("a",{parentName:"p",href:"create-selector"},"See more on why this approach helps with performance"),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Now you can subscribe to changes in a specific player's health!")," But creating this subscription for new players and unsubscribing when they are removed can be difficult to set up. This is where the ",(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," method comes in handy."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," takes a ",(0,r.kt)("strong",{parentName:"p"},"selector"),", an optional ",(0,r.kt)("strong",{parentName:"p"},"discriminator"),", and an ",(0,r.kt)("strong",{parentName:"p"},"Observer"),". The selector returns a list or record of items, in which the Observer is called when a unique item is added. The Observer may return a ",(0,r.kt)("strong",{parentName:"p"},"cleanup function")," that is automatically called when the item is removed from the list."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This code observes the lifetime of the players that are currently alive.")," The Observer can then subscribe to changes in the player's health, and run side effects when the player is damaged or dies. When the player is removed from the list, that means they are no longer alive, and the cleanup function is called."),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const discriminator = (player: GamePlayer) => player.id;\n\nproducer.observe(selectAlivePlayers, discriminator, (initialPlayer) => {\n    const { id } = initialPlayer;\n\n    const unsubscribe = producer.subscribe(selectPlayerHealth(id), (health, prevHealth) => {\n        if (health < prevHealth) {\n            playerDamaged();\n        }\n    });\n\n    return () => {\n        unsubscribe();\n        playerDied();\n    };\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function discriminator(player)\n    return player.id\nend\n\nproducer:observe(selectAlivePlayers, discriminator, function(initialPlayer)\n    local id = initialPlayer.id\n\n    local unsubscribe = producer:subscribe(selectPlayerHealth(id), function(health, prevHealth)\n        if health < prevHealth then\n            playerDamaged()\n        end\n    end)\n\n    return function()\n        unsubscribe()\n        playerDied()\n    end\nend)\n")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Remember to pass a discriminator function to ",(0,r.kt)("a",{parentName:"strong",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," if you're observing objects!")," Because of the nature of immutable data, discriminators are necessary to ensure an Observer exists through the entire lifecycle of an object.")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#observeselector-discriminator-observer"},(0,r.kt)("inlineCode",{parentName:"a"},"observe"))," receives three parameters:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," that returns a list or record of entries."),(0,r.kt)("li",{parentName:"ol"},"An optional ",(0,r.kt)("inlineCode",{parentName:"li"},"discriminator")," function that returns a unique identifier for each entry."),(0,r.kt)("li",{parentName:"ol"},"An ",(0,r.kt)("inlineCode",{parentName:"li"},"observer")," function that is called when an entry is added, and returns a cleanup function that is called when the entry is removed.")),(0,r.kt)("p",null,"The discriminator is optional in the case that your list contains primitives like strings and numbers:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nconst selectPlayerIds = createSelector([selectPlayers] as const, (players) => {\n    return players.map((player) => player.id);\n});\n// highlight-end\n\nproducer.observe(selectPlayerIds, (id: number) => {\n    // mounted\n    return () => {\n        // unmounted\n    };\n});\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"// highlight-start\nlocal selectPlayerIds = Reflex.createSelector({ selectPlayers }, function(players)\n    local ids = {}\n    for index, player in players do\n        ids[index] = player.id\n    end\n    return ids\nend)\n// highlight-end\n\nproducer:observe(selectPlayerIds, function(id: number)\n    -- mounted\n    return function()\n        -- unmounted\n    end\nend)\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"using-middleware"},"Using middleware"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Middleware is a powerful tool for extending the behavior of producers and actions.")," In Reflex, middleware can be used to add logging, cancel actions, analytics, add undo/redo functionality, and more."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This example is a custom implementation of ",(0,r.kt)("inlineCode",{parentName:"strong"},"loggerMiddleware"),":")),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const loggerMiddleware: ProducerMiddleware = (producer) => {\n    // First level, called by applyMiddleware\n\n    producer.subscribe((state) => {\n        print("state changed to", state);\n    });\n\n    return (dispatch, name) => {\n        // Second level, called per action function\n\n        return (...args) => {\n            // Third level, called before action dispatch\n\n            print("dispatching", name, "with", args);\n\n            return dispatch(...args);\n        };\n    };\n};\n\nproducer.applyMiddleware(loggerMiddleware);\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local loggerMiddleware: Reflex.Middleware = function(producer)\n    -- First level, called by applyMiddleware\n\n    producer:subscribe(function(state)\n        print("state changed to", state)\n    end)\n\n    return function(dispatch, name)\n        -- Second level, called action function\n\n        return function(...)\n            -- Third level, called before action dispatch\n\n            print("dispatching", name, "with", ...)\n\n            return dispatch(...)\n        end\n    end\nend\n\nproducer:applyMiddleware(loggerMiddleware)\n')))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A middleware has three layers of control that allow you to fine-tune behavior:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The producer"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The first level, the middleware itself, is called when it is applied to a producer."),(0,r.kt)("li",{parentName:"ul"},"You can make subscriptions or patch methods here."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"An action"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The second level is called once for every action in the producer, and receives a ",(0,r.kt)("inlineCode",{parentName:"li"},"dispatch")," function and the action name."),(0,r.kt)("li",{parentName:"ul"},"You might log a list of actions or permanently disable an action here."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"On dispatch"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The final level receives the action's arguments and calls ",(0,r.kt)("inlineCode",{parentName:"li"},"dispatch")," to invoke the next middleware in the chain."),(0,r.kt)("li",{parentName:"ul"},"You can cancel an action or log individual dispatches here.")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"The third level of middleware acts as a wrapper for actions.")," Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," will invoke the next middleware in the chain, or the action if it is the last middleware."),(0,r.kt)("p",{parentName:"admonition"},"Additionally, changing the arguments or return value in the third level will ",(0,r.kt)("strong",{parentName:"p"},"pass them on")," to the next middleware or action.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"using-multiple-producers"},"Using multiple producers"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Reflex is best used with a single producer holding the entire state of your application.")),(0,r.kt)("p",null,"It's good practice to organize state into different producers, and combine them with ",(0,r.kt)("a",{parentName:"p",href:"combine-producers"},(0,r.kt)("inlineCode",{parentName:"a"},"combineProducers")),". ",(0,r.kt)("a",{parentName:"p",href:"combine-producers"},"See the documentation for more details.")))}h.isMDXComponent=!0}}]);