"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[653],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),u=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(d.Provider,{value:t},e.children)},s="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),s=u(n),m=r,h=s["".concat(d,".").concat(m)]||s[m]||p[m]||l;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[s]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7233:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(9496),r=n(5924);const l={tabItem:"tabItem_Z2jM"};function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,i),hidden:n},t)}},5297:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(8028),r=n(9496),l=n(5924),i=n(1729),o=n(3442),d=n(5968),u=n(9458),c=n(371);function s(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??s(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,d._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=p(e),[i,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[d,u]=h({queryString:n,groupId:a}),[s,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,c.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),w=(()=>{const e=d??s;return m({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{w&&o(w)}),[w]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)}),[u,g,l]),tabValues:l}}var w=n(6489);const k={tabList:"tabList_Vrhz",tabItem:"tabItem_kl51"};function f(e){let{className:t,block:n,selectedValue:o,selectValue:d,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:s}=(0,i.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==o&&(s(t),d(a))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},i,{className:(0,l.Z)("tabs__item",k.tabItem,i?.className,{"tabs__item--active":o===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function y(e){const t=g(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",k.tabList)},r.createElement(f,(0,a.Z)({},e,t)),r.createElement(b,(0,a.Z)({},e,t)))}function N(e){const t=(0,w.Z)();return r.createElement(y,(0,a.Z)({key:String(t)},e))}},8988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>u,toc:()=>s});var a=n(8028),r=(n(9496),n(9613)),l=n(5297),i=n(7233);const o={description:"Learn how to use middleware in Reflex."},d="Middleware",u={unversionedId:"advanced-guides/middleware",id:"advanced-guides/middleware",title:"Middleware",description:"Learn how to use middleware in Reflex.",source:"@site/docs/advanced-guides/middleware.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/middleware",permalink:"/reflex/docs/advanced-guides/middleware",draft:!1,tags:[],version:"current",frontMatter:{description:"Learn how to use middleware in Reflex."},sidebar:"learnSidebar",previous:{title:"Advanced Guides",permalink:"/reflex/docs/advanced-guides/"},next:{title:"Server-Client Sync",permalink:"/reflex/docs/advanced-guides/server-client-sync"}},c={},s=[{value:"What is middleware?",id:"what-is-middleware",level:2},{value:"Using middleware",id:"using-middleware",level:2},{value:"Logging actions",id:"logging-actions",level:3},{value:"Crash reporting",id:"crash-reporting",level:3},{value:"Cancelling actions",id:"cancelling-actions",level:3},{value:"Using multiple middlewares",id:"using-multiple-middlewares",level:3},{value:"Ordering middleware",id:"ordering-middleware",level:2},{value:"Cancel actions to cancel middleware",id:"cancel-actions-to-cancel-middleware",level:3},{value:"Transforming arguments",id:"transforming-arguments",level:3},{value:"How does it look internally?",id:"how-does-it-look-internally",level:2},{value:"Summary",id:"summary",level:2}],p={toc:s},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"middleware"},"Middleware"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/middleware"},"Middleware")," is a powerful concept in Reflex that allows you to enhance your producer and actions with additional functionality."),(0,r.kt)("admonition",{title:"what you'll learn",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"\ud83e\udde9 What middleware is"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd0d The structure of middleware"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd0c How to use middleware"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udcdd How to write your own middleware"),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udcda Common middleware"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"what-is-middleware"},"What is middleware?"),(0,r.kt)("p",null,"In state management libraries, middleware provides a way to insert code in between the dispatch of an action, and the moment the action is called. It is often used to log actions, perform asynchronous tasks, or add additional data to the action."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"using-middleware"},"Using middleware"),(0,r.kt)("p",null,"Reflex middleware has three layers of control that enable you to customize the behavior of your producers in powerful ways. A basic middleware function looks like this:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const middleware: ProducerMiddleware = (producer) => {\n    return (nextAction, name) => {\n        return (...args) => nextAction(...args);\n    };\n};\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local middleware: Reflex.Middleware = function(producer)\n    return function(nextAction, name)\n        return function(...)\n            return nextAction(...)\n        end\n    end\nend\n")))),(0,r.kt)("p",null,"You can separate the middleware into three layers:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The producer"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The middleware itself is called once when it is initially applied to a producer."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The action wrapper"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This is called once per action when the middleware is applied, and receives a ",(0,r.kt)("inlineCode",{parentName:"li"},"nextAction")," function and the name of the action."),(0,r.kt)("li",{parentName:"ul"},"It returns a function that can run additional code before or after the next middleware or action runs."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The dispatcher"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This is called in place of the action during a dispatch, and can call ",(0,r.kt)("inlineCode",{parentName:"li"},"nextAction")," to run the action."),(0,r.kt)("li",{parentName:"ul"},"If middleware is applied after this one, ",(0,r.kt)("inlineCode",{parentName:"li"},"nextAction")," invokes the next middleware.")))),(0,r.kt)("p",null,"But this can be difficult to visualize, so let's try to build our own middleware."),(0,r.kt)("h3",{id:"logging-actions"},"Logging actions"),(0,r.kt)("p",null,"You may have learned how to ",(0,r.kt)("a",{parentName:"p",href:"../guides/subscribing-to-state"},"subscribe to state changes")," in a previous guide, but that covered running side effects when ",(0,r.kt)("em",{parentName:"p"},"state")," changes, not when actions are dispatched. What if you want to log the actions themselves as they happen?"),(0,r.kt)("p",null,"We can create a ",(0,r.kt)("strong",{parentName:"p"},"middleware")," that logs actions as they are dispatched. Let's start with the first layer of middleware, which is called when the middleware is applied to a producer. We'll use this layer to subscribe to state changes, so we can log how actions change the state:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const loggerMiddleware: ProducerMiddleware = (producer) => {\n    // highlight-start\n    producer.subscribe((state) => {\n        print("next state:", state);\n    });\n    // highlight-end\n\n    return (nextAction, name) => {\n        return (...args) => nextAction(...args);\n    };\n};\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local loggerMiddleware: Reflex.Middleware = function(producer)\n    // highlight-start\n    producer:subscribe(function(state)\n        print("next state:", state)\n    end)\n    // highlight-end\n\n    return function(nextAction, name)\n        return function(...)\n            return nextAction(...)\n        end\n    end\nend\n')))),(0,r.kt)("p",null,"The next ",(0,r.kt)("strong",{parentName:"p"},"action wrapper")," is called once per action when the middleware is applied, and returns a function that essentially ",(0,r.kt)("em",{parentName:"p"},"replaces")," the action in the producer. We'll use this to modify an action to log the action name and arguments before continuing with the dispatch:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const loggerMiddleware: ProducerMiddleware = (producer) => {\n    producer.subscribe((state) => {\n        print("next state:", state);\n    });\n\n    return (nextAction, name) => {\n        // highlight-start\n        return (...args) => {\n            print(`dispatching ${name}:`, ...args);\n            return nextAction(...args);\n        };\n        // highlight-end\n    };\n};\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local loggerMiddleware: Reflex.Middleware = function(producer)\n    producer:subscribe(function(state)\n        print("next state:", state)\n    end)\n\n    return function(nextAction, name)\n        // highlight-start\n        return function(...)\n            print("dispatching " .. name .. ":", ...)\n            return nextAction(...)\n        end\n        // highlight-end\n    end\nend\n')))),(0,r.kt)("p",null,"And that's it! We've built a middleware that logs actions as they are dispatched. We can apply it to our producer with ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/producer#applymiddlewaremiddlewares"},(0,r.kt)("inlineCode",{parentName:"a"},"applyMiddleware")),":"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const counter = createProducer(0, {\n    set: (state, value: number) => value,\n    increment: (state, amount: number) => state + amount,\n});\n\ncounter.applyMiddleware(loggerMiddleware);\ncounter.set(5);\ncounter.increment(1);\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local counter = Reflex.createProducer(0, {\n    set = function(state, value: number)\n        return value\n    end,\n    increment = function(state, amount: number)\n        return state + amount\n    end,\n})\n\ncounter:applyMiddleware(loggerMiddleware)\ncounter.set(5)\ncounter.increment(1)\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# dispatching set: 5\n# dispatching increment: 1\n# next state: 6\n")),(0,r.kt)("p",null,"Now, we can see the actions as they are dispatched, and how they change the state."),(0,r.kt)("p",null,"Reflex comes with a built-in ",(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/middleware#loggermiddleware"},(0,r.kt)("inlineCode",{parentName:"a"},"loggerMiddleware"))," that does exactly this, so you don't have to write it yourself."),(0,r.kt)("h3",{id:"crash-reporting"},"Crash reporting"),(0,r.kt)("p",null,"Another common use case for middleware is crash reporting. You can use middleware to catch errors in your actions, and report them as they happen:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const crashReporterMiddleware: ProducerMiddleware = (producer) => {\n    return (nextAction, name) => {\n        return (...args) => {\n            try {\n                return nextAction(...args);\n            } catch (error) {\n                warn(`caught error in ${name}:`, error);\n                return producer.getState();\n            }\n        };\n    };\n};\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local crashReporterMiddleware: Reflex.Middleware = function(producer)\n    return function(action, name)\n        return function(...)\n            local success, result = pcall(action, ...)\n            if not success then\n                warn("caught error in " .. name .. ":", result)\n                return producer:getState()\n            end\n            return result\n        end\n    end\nend\n')))),(0,r.kt)("p",null,"If an error is thrown by an action or a later middleware, the crash reporter will catch it and log it, then return the current state. This prevents the error from propagating to the rest of the game."),(0,r.kt)("h3",{id:"cancelling-actions"},"Cancelling actions"),(0,r.kt)("p",null,"You can also use middleware to cancel actions. If you don't want an action to be dispatched, you can return the current state instead of calling the next action:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const cancelMiddleware: ProducerMiddleware = (producer) => {\n    return (nextAction, name) => {\n        if (name !== "increment") {\n            return nextAction;\n        }\n\n        return (...args) => {\n            print("cancelled increment!");\n            // highlight-next-line\n            return producer.getState();\n        };\n    };\n};\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local cancelMiddleware: Reflex.Middleware = function(producer)\n    return function(nextAction, name)\n        if name ~= "increment" then\n            return nextAction\n        end\n\n        return function(...)\n            print("cancelled increment!")\n            // highlight-next-line\n            return producer:getState()\n        end\n    end\nend\n')))),(0,r.kt)("p",null,"Now, if we apply this middleware to our producer, we can see that the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action is cancelled:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const counter = createProducer(0, {\n    set: (state, value: number) => value,\n    increment: (state, amount: number) => state + amount,\n});\n\ncounter.applyMiddleware(cancelMiddleware);\ncounter.set(5);\ncounter.increment(1);\nprint(counter.getState());\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local counter = Reflex.createProducer(0, {\n    set = function(state, value: number)\n        return value\n    end,\n    increment = function(state, amount: number)\n        return state + amount\n    end,\n})\n\ncounter:applyMiddleware(cancelMiddleware)\ncounter.set(5)\ncounter.increment(1)\nprint(counter:getState())\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# cancelled increment!\n# 5\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Cancelling an action also prevents the middleware ",(0,r.kt)("em",{parentName:"p"},"after")," ",(0,r.kt)("inlineCode",{parentName:"p"},"cancelMiddleware")," from being called! This means that if you want some middleware to never get cancelled by ",(0,r.kt)("inlineCode",{parentName:"p"},"cancelMiddleware"),", pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," before it.")),(0,r.kt)("h3",{id:"using-multiple-middlewares"},"Using multiple middlewares"),(0,r.kt)("p",null,"You can apply multiple middlewares to a producer, and they will be called in the order they are applied. This means that the first middleware will be called with your initial arguments, and the last middleware will invoke the original action."),(0,r.kt)("p",null,"Let's try applying both the logger and cancel middlewares to our producer:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const counter = createProducer(0, {\n    set: (state, value: number) => value,\n    increment: (state, amount: number) => state + amount,\n});\n\ncounter.applyMiddleware(cancelMiddleware, loggerMiddleware);\ncounter.set(5);\ncounter.increment(1);\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local counter = Reflex.createProducer(0, {\n    set = function(state, value: number)\n        return value\n    end,\n    increment = function(state, amount: number)\n        return state + amount\n    end,\n})\n\ncounter:applyMiddleware(cancelMiddleware, loggerMiddleware)\ncounter.set(5)\ncounter.increment(1)\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# dispatching set: 5\n# cancelled increment!\n# next state: 5\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," action set the state to ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),", and the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action was cancelled, so the final state was determined to be ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),"."),(0,r.kt)("p",null,"But wait, why didn't the logger middleware print the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action? That's because the order of middleware matters!"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ordering-middleware"},"Ordering middleware"),(0,r.kt)("p",null,"The order in which you apply middleware is important. If the first middleware cancels an action, the rest of the middleware will not be called. This means that middleware that you want to always run should be applied first, and middleware that you want to run last should be applied last."),(0,r.kt)("h3",{id:"cancel-actions-to-cancel-middleware"},"Cancel actions to cancel middleware"),(0,r.kt)("p",null,"In the last section, we applied a cancel middleware and a logger middleware to our producer. The call chain looked like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"counter.increment(1)\n// error-next-line\n=> cancel(1) // \ud83d\udd34 Cancelled\n=> logger(1)\n=> increment(1)\n")),(0,r.kt)("p",null,"If we also want to log cancelled actions, we need to apply the logger middleware ",(0,r.kt)("em",{parentName:"p"},"before")," the cancel middleware:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"counter.applyMiddleware(loggerMiddleware, cancelMiddleware);\ncounter.increment(1);\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"counter:applyMiddleware(loggerMiddleware, cancelMiddleware)\ncounter.increment(1)\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"counter.increment(1)\n=> logger(1)\n// error-next-line\n=> cancel(1) // \ud83d\udd34 Cancelled\n=> increment(1)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# dispatching increment: 1\n# cancelled increment!\n")),(0,r.kt)("h3",{id:"transforming-arguments"},"Transforming arguments"),(0,r.kt)("p",null,"We can also insert a middleware that modifies the action's arguments! Let's say we want to double the amount that the counter is incremented by:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const doubleMiddleware: ProducerMiddleware = (producer) => {\n    return (nextAction, name) => {\n        if (name !== "increment") {\n            return nextAction;\n        }\n\n        return (amount: number) => {\n            // highlight-next-line\n            return nextAction(amount * 2);\n        };\n    };\n};\n'))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local doubleMiddleware: Reflex.Middleware = function(producer)\n    return function(nextAction, name)\n        if name ~= "increment" then\n            return nextAction\n        end\n\n        return function(amount: number)\n            // highlight-next-line\n            return nextAction(amount * 2)\n        end\n    end\nend\n')))),(0,r.kt)("p",null,"This middleware will double the amount that the counter is incremented by, but only if the action is an ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action. If it's named anything else, it will skip the middleware and call the next one in the chain."),(0,r.kt)("p",null,"Let's apply this middleware to our producer, and see what happens:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const counter = createProducer(0, {\n    set: (state, value: number) => value,\n    increment: (state, amount: number) => state + amount,\n});\n\ncounter.applyMiddleware(doubleMiddleware, loggerMiddleware);\ncounter.set(5);\ncounter.increment(1);\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local counter = Reflex.createProducer(0, {\n    set = function(state, value: number)\n        return value\n    end,\n    increment = function(state, amount: number)\n        return state + amount\n    end,\n})\n\ncounter:applyMiddleware(doubleMiddleware, loggerMiddleware)\ncounter.set(5)\ncounter.increment(1)\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.increment(1)\n// highlight-start\n=> double(1)\n=> logger(1 * 2)\n// highlight-end\n=> increment(2)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# dispatching set: 5\n# dispatching increment: 2\n# next state: 7\n")),(0,r.kt)("p",null,"As you can see, the increment amount was doubled because ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," called ",(0,r.kt)("inlineCode",{parentName:"p"},"logger")," with the doubled amount, and the logger middleware received doubled amount."),(0,r.kt)("p",null,"However, if we apply the logger middleware ",(0,r.kt)("em",{parentName:"p"},"before")," the double middleware, we get a different output:"),(0,r.kt)(l.Z,{groupId:"languages",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"TypeScript",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.applyMiddleware(loggerMiddleware, doubleMiddleware);\nproducer.set(5);\nproducer.increment(1);\n"))),(0,r.kt)(i.Z,{value:"Luau",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"producer:applyMiddleware(loggerMiddleware, doubleMiddleware)\nproducer.set(5)\nproducer.increment(1)\n")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.increment(1)\n// highlight-next-line\n=> logger(1)\n=> double(1)\n=> increment(1 * 2)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Output"',title:'"Output"'},"# dispatching set: 5\n# dispatching increment: 1\n# next state: 7\n")),(0,r.kt)("p",null,"As you can see, the next state is still ",(0,r.kt)("inlineCode",{parentName:"p"},"7")," even though the logger said the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," was incremented by ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),". This is because the logger middleware received the number ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," ",(0,r.kt)("em",{parentName:"p"},"before")," the double middleware could transform it in the chain, so it logged the original amount."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This is why the order in which you apply middleware is important.")," If you have a middleware that modifies the action or its results, and you want another middleware to work with the initial data, you should apply the second middleware ",(0,r.kt)("em",{parentName:"p"},"before")," the first one, so it gets called first."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"how-does-it-look-internally"},"How does it look internally?"),(0,r.kt)("p",null,"If you're curious about how Reflex applies middleware, here's a technical look at how the middlewares from the ",(0,r.kt)("a",{parentName:"p",href:"#ordering-middleware"},"ordering middleware")," section is applied to the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"producer.applyMiddleware(loggerMiddleware, cancelMiddleware, doubleMiddleware);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// The middleware is called and returns an action wrapper\nconst doubleWrapper = doubleMiddleware(counter);\nconst cancelWrapper = cancelMiddleware(counter);\nconst loggerWrapper = loggerMiddleware(counter);\n\n// The action wrapper is called, where \'nextAction\' is the next\n// action or middleware in the chain\ncounter.increment = doubleWrapper(counter.increment, "increment");\ncounter.increment = cancelWrapper(counter.increment, "increment");\ncounter.increment = loggerWrapper(counter.increment, "increment");\n\n// Calling this action goes through the middleware chain first:\n// => logger(1)\n// => cancel(1)\n// => double(1)\n// => increment(1 * 2)\ncounter.increment = doubleIncrement;\n')),(0,r.kt)("admonition",{title:"why are middlewares called in reverse?",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"nextAction")," argument passed to the action wrapper is the ",(0,r.kt)("em",{parentName:"p"},"next")," action or middleware in the chain, but we can only know the next action by calling its action wrapper first. By composing the middleware functions in reverse, we can make sure that:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"loggerAction")," is called first, and invokes ",(0,r.kt)("inlineCode",{parentName:"li"},"cancelAction")," with the result"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"cancelAction")," is called next, and invokes ",(0,r.kt)("inlineCode",{parentName:"li"},"doubleAction")," next if it wasn't cancelled"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"doubleAction")," is called last, and calls the ",(0,r.kt)("inlineCode",{parentName:"li"},"increment")," action with the doubled amount")),(0,r.kt)("p",{parentName:"admonition"},"You can imagine the chain being composed like this:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"loggerWrapper(cancelWrapper(doubleWrapper(counter.increment)));\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Middleware")," is used to run code in between an action dispatch and the moment it updates the state."),(0,r.kt)("li",{parentName:"ul"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},"applyMiddleware")," on a producer to apply middleware to it."),(0,r.kt)("li",{parentName:"ul"},"You can use middleware to ",(0,r.kt)("strong",{parentName:"li"},"cancel")," an action or ",(0,r.kt)("strong",{parentName:"li"},"transform")," its input or output."),(0,r.kt)("li",{parentName:"ul"},"Cancelling an action will also prevent any middleware after it from running."),(0,r.kt)("li",{parentName:"ul"},"The order in which you apply middleware is important.")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../reference/reflex/middleware"},"Read more on middleware \u2192")))}h.isMDXComponent=!0}}]);